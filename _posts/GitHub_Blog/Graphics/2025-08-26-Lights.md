---
title: "라이팅 개념"
date : "2025-08-26 19:30:00 +0900"
last_modified_at: "2025-08-27T19:30:00"
categories:
  - Direct X
  - 그래픽스
tags:
  - 라이팅
  - hlsli 확장자
---

## Light

### 게임에서 빛의 종류
<img width="568" height="219" alt="Image" src="https://github.com/user-attachments/assets/1fa0a8e5-5863-4270-a5b1-331c82bac678" /><br>

- Directional Light (방향광)<br>
  : '태양빛' 같이 '방향'만 있으며<br>
   거리에 따른 '감쇠'가 없음<br>
   (보통 LightDir 로 처리)<br>

- Point Light(점광원)<br>
  : '전구'처럼 한 점에서 모든 방향으로 퍼짐<br>
  거리 감쇠(Attenuation) 구현 필요<br>
  (L = normalize(LightPos - FragPos));

- Spot Light(스포트라이트)<br>
  : 원뿔 모양으로 퍼지는 빛(손전등)<br>
  각도와 거리 감쇠를 함께 계산<br>

- Ambient Light(환경광)<br>
  : 전체적으로 약간 밟게 유지하는 균일한 빛<br>
    직접광이 없어도 완전히 까맣지 않게<br>
    (Phong 모델에선 상수 값으로 덮어씌워 구현)<br>
    (PBR 등에선 시뮬레이션 등을 통해 실제로 환경광을 계산)<br>

### 광원 모델

- Lambert (램버트 조명)<br>
  : Diffuse를 구할때 많이 사용<br>
  I=kd​⋅(N⋅L)⋅IL​ <br>
  - I : 최종 밝기<br>
  - Kd : Diffuse의 반사율 (재질 고유 색상, Albedo)<br>
  - N : 법선 벡터(Normal)<br>
  - L : 광원 방향 벡터(Light Direction, 정규화됨)<br>
  - (N⋅L) : 내적을 통한 입사각 효과 (빛이 직각일수록 많이 받으며, 측면일수록 약해짐)<br>
  - IL : 광원 자체의 세기(Intensity of Light Source)<br>

- Phong Reflection Model<br>
  : 고전적인 조명 공식<br>
  I=ka​Ia​+kd​(N⋅L)IL​+ks​(R⋅V)αIL​<br>
  - I : 최종 밝기<br>
  - Ka : Ambient 반사율 (재질이 환경광을 반사하는 정도)<br>
  - Ia : Ambient Light 강도(환경광 세기)<br>
  - Kd : Diffuse의 반사율 (재질 고유 색상, Albedo)<br>
  - N : 법선 벡터(Normal)<br>
  - L : 광원 방향 벡터(Light Direction, 정규화됨)<br>
  - (N⋅L) : 내적을 통한 입사각 효과 (빛이 직각일수록 많이 받으며, 측면일수록 약해짐)<br>
  - IL : 광원 자체의 세기(Intensity of Light Source)<br>
  - Ks : Specular 반사율 (얼마나 빛을 잘 반사하는지, 0이면 없음)<br>
  - R : 반사 벡터(빛이 표면에서 반사된 방향)<br>
  - V : 뷰어(카메라) 방향 벡터<br>
  - ​(R⋅V)α : 스페큘러 강도 (α : 하이라이트의 날카로움 -> Shininess)<br>

- Blinn-Phong<br>
  : Phong의 개선 버전<br>
    Half Vector를 이용<br>
    연산량 절감 + 더 자연스러운 하이라이트<br>
  I=ka​Ia​+kd​(N⋅L)IL​+ks​(N⋅H)αIL​<br>
  - H : HalfVector(광원방향 L과 뷰어 방향 V의 중간 벡터)<br>
    - H=L+V​ / ∣L+V∣<br>
  - 나머지는 Phong과 동일<br>
  - R⋅V 대신, N⋅H 를 이용N⋅H
  

- PBR(Phsically Based Rendering)<br>
  : 물리 기반 모델, 현대 게임 그래픽스 표준(Unreal 등)<br>
  fr​(L,V)= D(h)⋅F(V,h)⋅G(N,V,L)​ / 4(N⋅V)(N⋅L)<br>
  - fr : BRDF (Bidirectional Reflectance Distribution Function)<br>
  - D(h) : Normal Distribution Function (NDF, 거칠기 → Roughness)<br>
  - F(V,h) : Fresnel Term (시선 각도에 따른 반사율 변화)<br>
  - G(N,V,L) : Geometry Term (마이크로 셰도잉, 빛이 미세 표면에서 가려지는 정도)<br>
  - h : half vector <br>
  - 𝑁⋅𝑉,𝑁⋅𝐿 : 입사/출사 각도의 영향<br>

### 감쇠
<img width="584" height="450" alt="Image" src="https://github.com/user-attachments/assets/5cddac84-f243-4de8-b622-e73f9e7bb153" /><br>

거리 감쇠로서<br>
시작점 -> 거리 D까지의 선형보간<br>

- fallOffStart 까지는 1의 가중치(감쇠 x)<br>
- fallOffEnd를 넘어가면 0의 가중치(보이지 않음)<br>
- 거리가 같더라도 fallOffEnd가 더 긴쪽이 더 밟게 보인다<br>

SpotLight 구현은<br>
'각도 감쇠'또한 필요하다<br>
(내각,외각에 따라 원뿔 가장자리 처리가 달라진다 함)<br>

### PBR 제외 예시코드(C++, HLSL 아님!)

```
vec3 BlinnPhong(vec3 lightStrength, vec3 lightVec, vec3 normal, vec3 toEye,
                Material mat) {

    vec3 halfway = normalize(toEye + lightVec);
    vec3 specular =
        mat.specular * pow(glm::max(dot(halfway, normal), 0.0f), mat.shininess);

    return mat.ambient + (mat.diffuse + specular) * lightStrength;
}

vec3 ComputeDirectionalLight(Light L, Material mat, vec3 normal, vec3 toEye) {
    vec3 lightVec = -L.direction;

    float ndotl = glm::max(dot(lightVec, normal), 0.0f);
    vec3 lightStrength = L.strength * ndotl;

    // Luna DX12 책에서는 Specular 계산에도
    // Lambert's law가 적용된 lightStrength를 사용합니다.
    return BlinnPhong(lightStrength, lightVec, normal, toEye, mat);
}

// 쉐이더에서 많이 사용되는 함수입니다. HLSL에는 내장되어 있습니다.
// https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-saturate
float Saturate(float x) { return glm::max(0.0f, glm::min(1.0f, x)); }

float CalcAttenuation(float d, float falloffStart, float falloffEnd) {
    // Linear falloff
    return Saturate((falloffEnd - d) / (falloffEnd - falloffStart));
}

vec3 ComputePointLight(Light L, Material mat, vec3 pos, vec3 normal,
                       vec3 toEye) {
    vec3 lightVec = L.position - pos;

    // 쉐이딩할 지점부터 조명까지의 거리 계산
    float d = length(lightVec);

    // 너무 멀면 조명이 적용되지 않음
    if (d > L.fallOffEnd)
        return vec3(0.0f);

    lightVec /= d;

    float ndotl = glm::max(dot(lightVec, normal), 0.0f);
    vec3 lightStrength = L.strength * ndotl;

    float att = CalcAttenuation(d, L.fallOffStart, L.fallOffEnd);
    lightStrength *= att;

    return BlinnPhong(lightStrength, lightVec, normal, toEye, mat);
}

vec3 ComputeSpotLight(Light L, Material mat, vec3 pos, vec3 normal,
                      vec3 toEye) {
    vec3 lightVec = L.position - pos;

    // 쉐이딩할 지점부터 조명까지의 거리 계산
    float d = length(lightVec);

    // 너무 멀면 조명이 적용되지 않음
    if (d > L.fallOffEnd)
        return vec3(0.0f);

    lightVec /= d;

    float ndotl = glm::max(dot(lightVec, normal), 0.0f);
    vec3 lightStrength = L.strength * ndotl;

    float att = CalcAttenuation(d, L.fallOffStart, L.fallOffEnd);
    lightStrength *= att;

    // float spotFactor = ...;
    // lightStrength *= spotFactor;

    return BlinnPhong(lightStrength, lightVec, normal, toEye, mat);
}
```

## hlsli 확장자
일반적으로 HLSL Include의 줄임말<br>
보통 쉐이더 코드에서 공용으로 사용하는 상수,함수, 구조체 등을<br>
모아두는 '헤더 파일' 개념<br>

- 개발자들이 관례적으로 만든 확장자<br>
  (C++의 hpp 같이 '표준 확장자'는 아님)<br>

- 사용처?<br>
  : 공용 상수 버퍼 정의, 반복 사용 함수, 구조체 정의 등을 포함시킨다<br>

- Item Type(항목 형식)을<br>
  : Does not participate in build (빌드에 참여 안함)<br>
   으로 설정해야 한다<br>
   (아니면 '메인 함수'를 찾을 수 없다는 에러 발생)<br>
   (그렇지만 쉐이더가 아니므로, main 함수 같은 진입점이 있으면 안됨)<br>

예시 파일<br>

```
// 쉐이더에서 include할 내용들은 .hlsli 파일에 작성
// Properties -> Item Type: Does not participate in build으로 설정

#define MAX_LIGHTS 3 // 쉐이더에서도 #define 사용 가능
#define NUM_DIR_LIGHTS 1
#define NUM_POINT_LIGHTS 1
#define NUM_SPOT_LIGHTS 1

// 재질
struct Material
{
    float3 ambient;
    float shininess;
    float3 diffuse;
    float dummy1; // 16 bytes 맞춰주기 위해 추가
    float3 specular;
    float dummy2;
};

// 조명
struct Light
{
    float3 strength;
    float fallOffStart;
    float3 direction;
    float fallOffEnd;
    float3 position;
    float spotPower;
};

float CalcAttenuation(float d, float falloffStart, float falloffEnd)
{
    // Linear falloff
    return saturate((falloffEnd - d) / (falloffEnd - falloffStart));
}

...

struct VertexShaderInput
{
    float3 posModel : POSITION; //모델 좌표계의 위치 position
    float3 normalModel : NORMAL; // 모델 좌표계의 normal    
    float2 texcoord : TEXCOORD0; // <- 다음 예제에서 사용
    
    // float3 color : COLOR0; <- 불필요 (쉐이딩)
};

struct PixelShaderInput
{
    float4 posProj : SV_POSITION; // Screen position
    float3 posWorld : POSITION; // World position (조명 계산에 사용)
    float3 normalWorld : NORMAL;
    float2 texcoord : TEXCOORD;
    
    // float3 color : COLOR; <- 불필요 (쉐이딩)
};
```

실제 쉐이더 파일에서 사용할때는<br>

```
#include "Common.hlsli" // 쉐이더에서도 include 사용 가능
```

이런식으로 사용한다<br>