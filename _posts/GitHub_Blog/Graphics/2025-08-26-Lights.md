---
title: "ë¼ì´íŒ… ê°œë…"
date : "2025-08-26 19:30:00 +0900"
last_modified_at: "2025-08-27T19:30:00"
categories:
  - Direct X
  - ê·¸ë˜í”½ìŠ¤
tags:
  - ë¼ì´íŒ…
  - hlsli í™•ì¥ì
---

## Light

### ê²Œì„ì—ì„œ ë¹›ì˜ ì¢…ë¥˜
<img width="568" height="219" alt="Image" src="https://github.com/user-attachments/assets/1fa0a8e5-5863-4270-a5b1-331c82bac678" /><br>

- Directional Light (ë°©í–¥ê´‘)<br>
  : 'íƒœì–‘ë¹›' ê°™ì´ 'ë°©í–¥'ë§Œ ìˆìœ¼ë©°<br>
   ê±°ë¦¬ì— ë”°ë¥¸ 'ê°ì‡ 'ê°€ ì—†ìŒ<br>
   (ë³´í†µ LightDir ë¡œ ì²˜ë¦¬)<br>

- Point Light(ì ê´‘ì›)<br>
  : 'ì „êµ¬'ì²˜ëŸ¼ í•œ ì ì—ì„œ ëª¨ë“  ë°©í–¥ìœ¼ë¡œ í¼ì§<br>
  ê±°ë¦¬ ê°ì‡ (Attenuation) êµ¬í˜„ í•„ìš”<br>
  (L = normalize(LightPos - FragPos));

- Spot Light(ìŠ¤í¬íŠ¸ë¼ì´íŠ¸)<br>
  : ì›ë¿” ëª¨ì–‘ìœ¼ë¡œ í¼ì§€ëŠ” ë¹›(ì†ì „ë“±)<br>
  ê°ë„ì™€ ê±°ë¦¬ ê°ì‡ ë¥¼ í•¨ê»˜ ê³„ì‚°<br>

- Ambient Light(í™˜ê²½ê´‘)<br>
  : ì „ì²´ì ìœ¼ë¡œ ì•½ê°„ ë°Ÿê²Œ ìœ ì§€í•˜ëŠ” ê· ì¼í•œ ë¹›<br>
    ì§ì ‘ê´‘ì´ ì—†ì–´ë„ ì™„ì „íˆ ê¹Œë§£ì§€ ì•Šê²Œ<br>
    (Phong ëª¨ë¸ì—ì„  ìƒìˆ˜ ê°’ìœ¼ë¡œ ë®ì–´ì”Œì›Œ êµ¬í˜„)<br>
    (PBR ë“±ì—ì„  ì‹œë®¬ë ˆì´ì…˜ ë“±ì„ í†µí•´ ì‹¤ì œë¡œ í™˜ê²½ê´‘ì„ ê³„ì‚°)<br>

### ê´‘ì› ëª¨ë¸

- Lambert (ë¨ë²„íŠ¸ ì¡°ëª…)<br>
  : Diffuseë¥¼ êµ¬í• ë•Œ ë§ì´ ì‚¬ìš©<br>
  I=kdâ€‹â‹…(Nâ‹…L)â‹…ILâ€‹ <br>
  - I : ìµœì¢… ë°ê¸°<br>
  - Kd : Diffuseì˜ ë°˜ì‚¬ìœ¨ (ì¬ì§ˆ ê³ ìœ  ìƒ‰ìƒ, Albedo)<br>
  - N : ë²•ì„  ë²¡í„°(Normal)<br>
  - L : ê´‘ì› ë°©í–¥ ë²¡í„°(Light Direction, ì •ê·œí™”ë¨)<br>
  - (Nâ‹…L) : ë‚´ì ì„ í†µí•œ ì…ì‚¬ê° íš¨ê³¼ (ë¹›ì´ ì§ê°ì¼ìˆ˜ë¡ ë§ì´ ë°›ìœ¼ë©°, ì¸¡ë©´ì¼ìˆ˜ë¡ ì•½í•´ì§)<br>
  - IL : ê´‘ì› ìì²´ì˜ ì„¸ê¸°(Intensity of Light Source)<br>

- Phong Reflection Model<br>
  : ê³ ì „ì ì¸ ì¡°ëª… ê³µì‹<br>
  I=kaâ€‹Iaâ€‹+kdâ€‹(Nâ‹…L)ILâ€‹+ksâ€‹(Râ‹…V)Î±ILâ€‹<br>
  - I : ìµœì¢… ë°ê¸°<br>
  - Ka : Ambient ë°˜ì‚¬ìœ¨ (ì¬ì§ˆì´ í™˜ê²½ê´‘ì„ ë°˜ì‚¬í•˜ëŠ” ì •ë„)<br>
  - Ia : Ambient Light ê°•ë„(í™˜ê²½ê´‘ ì„¸ê¸°)<br>
  - Kd : Diffuseì˜ ë°˜ì‚¬ìœ¨ (ì¬ì§ˆ ê³ ìœ  ìƒ‰ìƒ, Albedo)<br>
  - N : ë²•ì„  ë²¡í„°(Normal)<br>
  - L : ê´‘ì› ë°©í–¥ ë²¡í„°(Light Direction, ì •ê·œí™”ë¨)<br>
  - (Nâ‹…L) : ë‚´ì ì„ í†µí•œ ì…ì‚¬ê° íš¨ê³¼ (ë¹›ì´ ì§ê°ì¼ìˆ˜ë¡ ë§ì´ ë°›ìœ¼ë©°, ì¸¡ë©´ì¼ìˆ˜ë¡ ì•½í•´ì§)<br>
  - IL : ê´‘ì› ìì²´ì˜ ì„¸ê¸°(Intensity of Light Source)<br>
  - Ks : Specular ë°˜ì‚¬ìœ¨ (ì–¼ë§ˆë‚˜ ë¹›ì„ ì˜ ë°˜ì‚¬í•˜ëŠ”ì§€, 0ì´ë©´ ì—†ìŒ)<br>
  - R : ë°˜ì‚¬ ë²¡í„°(ë¹›ì´ í‘œë©´ì—ì„œ ë°˜ì‚¬ëœ ë°©í–¥)<br>
  - V : ë·°ì–´(ì¹´ë©”ë¼) ë°©í–¥ ë²¡í„°<br>
  - â€‹(Râ‹…V)Î± : ìŠ¤í˜í˜ëŸ¬ ê°•ë„ (Î± : í•˜ì´ë¼ì´íŠ¸ì˜ ë‚ ì¹´ë¡œì›€ -> Shininess)<br>

- Blinn-Phong<br>
  : Phongì˜ ê°œì„  ë²„ì „<br>
    Half Vectorë¥¼ ì´ìš©<br>
    ì—°ì‚°ëŸ‰ ì ˆê° + ë” ìì—°ìŠ¤ëŸ¬ìš´ í•˜ì´ë¼ì´íŠ¸<br>
  I=kaâ€‹Iaâ€‹+kdâ€‹(Nâ‹…L)ILâ€‹+ksâ€‹(Nâ‹…H)Î±ILâ€‹<br>
  - H : HalfVector(ê´‘ì›ë°©í–¥ Lê³¼ ë·°ì–´ ë°©í–¥ Vì˜ ì¤‘ê°„ ë²¡í„°)<br>
    - H=L+Vâ€‹ / âˆ£L+Vâˆ£<br>
  - ë‚˜ë¨¸ì§€ëŠ” Phongê³¼ ë™ì¼<br>
  - Râ‹…V ëŒ€ì‹ , Nâ‹…H ë¥¼ ì´ìš©Nâ‹…H
  

- PBR(Phsically Based Rendering)<br>
  : ë¬¼ë¦¬ ê¸°ë°˜ ëª¨ë¸, í˜„ëŒ€ ê²Œì„ ê·¸ë˜í”½ìŠ¤ í‘œì¤€(Unreal ë“±)<br>
  frâ€‹(L,V)= D(h)â‹…F(V,h)â‹…G(N,V,L)â€‹ / 4(Nâ‹…V)(Nâ‹…L)<br>
  - fr : BRDF (Bidirectional Reflectance Distribution Function)<br>
  - D(h) : Normal Distribution Function (NDF, ê±°ì¹ ê¸° â†’ Roughness)<br>
  - F(V,h) : Fresnel Term (ì‹œì„  ê°ë„ì— ë”°ë¥¸ ë°˜ì‚¬ìœ¨ ë³€í™”)<br>
  - G(N,V,L) : Geometry Term (ë§ˆì´í¬ë¡œ ì…°ë„ì‰, ë¹›ì´ ë¯¸ì„¸ í‘œë©´ì—ì„œ ê°€ë ¤ì§€ëŠ” ì •ë„)<br>
  - h : half vector <br>
  - ğ‘â‹…ğ‘‰,ğ‘â‹…ğ¿ : ì…ì‚¬/ì¶œì‚¬ ê°ë„ì˜ ì˜í–¥<br>

### ê°ì‡ 
<img width="584" height="450" alt="Image" src="https://github.com/user-attachments/assets/5cddac84-f243-4de8-b622-e73f9e7bb153" /><br>

ê±°ë¦¬ ê°ì‡ ë¡œì„œ<br>
ì‹œì‘ì  -> ê±°ë¦¬ Dê¹Œì§€ì˜ ì„ í˜•ë³´ê°„<br>

- fallOffStart ê¹Œì§€ëŠ” 1ì˜ ê°€ì¤‘ì¹˜(ê°ì‡  x)<br>
- fallOffEndë¥¼ ë„˜ì–´ê°€ë©´ 0ì˜ ê°€ì¤‘ì¹˜(ë³´ì´ì§€ ì•ŠìŒ)<br>
- ê±°ë¦¬ê°€ ê°™ë”ë¼ë„ fallOffEndê°€ ë” ê¸´ìª½ì´ ë” ë°Ÿê²Œ ë³´ì¸ë‹¤<br>

SpotLight êµ¬í˜„ì€<br>
'ê°ë„ ê°ì‡ 'ë˜í•œ í•„ìš”í•˜ë‹¤<br>
(ë‚´ê°,ì™¸ê°ì— ë”°ë¼ ì›ë¿” ê°€ì¥ìë¦¬ ì²˜ë¦¬ê°€ ë‹¬ë¼ì§„ë‹¤ í•¨)<br>

### PBR ì œì™¸ ì˜ˆì‹œì½”ë“œ(HLSL)

```
float CalcAttenuation(float d, float falloffStart, float falloffEnd)
{
    // Linear falloff
    return saturate((falloffEnd - d) / (falloffEnd - falloffStart));
}

float3 BlinnPhong(float3 lightStrength, float3 lightVec, float3 normal,
                   float3 toEye, Material mat)
{
    float3 halfway = normalize(toEye + lightVec);
    float3 specular = mat.specular * pow(max(dot(halfway, normal), 0.0), mat.shininess);
    
    return mat.ambient + (mat.diffuse + specular) * lightStrength;
}

float3 ComputeDirectionalLight(Light L, Material mat, float3 normal,
                                float3 toEye)
{
    float3 lightVec = -L.direction;
    float ndotl = max(dot(lightVec, normal), 0.0);
    float3 lightStrength = L.strength * ndotl;
    
    return BlinnPhong(lightStrength,lightVec,normal,toEye,mat);
}

float3 ComputePointLight(Light L, Material mat, float3 pos, float3 normal,
                          float3 toEye)
{
    float3 lightVec = L.position - pos;

    // ì‰ì´ë”©í•  ì§€ì ë¶€í„° ì¡°ëª…ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
    float d = length(lightVec);

    // ë„ˆë¬´ ë©€ë©´ ì¡°ëª…ì´ ì ìš©ë˜ì§€ ì•ŠìŒ
    if (d > L.fallOffEnd)
    {
        return float3(0.0, 0.0, 0.0);
    }
    else
    {
        lightVec /= d;
        float ndotl = max(dot(lightVec, normal), 0.0);
        
        float3 lightStrength = L.strength * ndotl;
        float att = CalcAttenuation(d, L.fallOffStart, L.fallOffEnd);
        lightStrength *= att;
        
        return BlinnPhong(lightStrength,lightVec,normal,toEye,mat);
    }
}

float3 ComputeSpotLight(Light L, Material mat, float3 pos, float3 normal,
                         float3 toEye)
{
    float3 lightVec = L.position - pos;

    // ì‰ì´ë”©í•  ì§€ì ë¶€í„° ì¡°ëª…ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
    float d = length(lightVec);

    // ë„ˆë¬´ ë©€ë©´ ì¡°ëª…ì´ ì ìš©ë˜ì§€ ì•ŠìŒ
    if (d > L.fallOffEnd)
    {
        return float3(0.0f, 0.0f, 0.0f);
    }
    else
    {
        lightVec /= d;
        float ndotl = max(dot(lightVec, normal), 0.0);
        
        float3 lightStrength = L.strength * ndotl;
        float att = CalcAttenuation(d, L.fallOffStart, L.fallOffEnd);
        lightStrength *= att;
        
        float spotFactor = pow(max(-dot(lightVec, L.direction), 0.0), L.spotPower);
        lightStrength *= spotFactor;
        
        return BlinnPhong(lightStrength, lightVec, normal, toEye, mat);
    }
    
    // ifì— elseê°€ ì—†ì„ ê²½ìš° ê²½ê³  ë°œìƒ
    // warning X4000: use of potentially uninitialized variable
}
```

## hlsli í™•ì¥ì
ì¼ë°˜ì ìœ¼ë¡œ HLSL Includeì˜ ì¤„ì„ë§<br>
ë³´í†µ ì‰ì´ë” ì½”ë“œì—ì„œ ê³µìš©ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ìƒìˆ˜,í•¨ìˆ˜, êµ¬ì¡°ì²´ ë“±ì„<br>
ëª¨ì•„ë‘ëŠ” 'í—¤ë” íŒŒì¼' ê°œë…<br>

- ê°œë°œìë“¤ì´ ê´€ë¡€ì ìœ¼ë¡œ ë§Œë“  í™•ì¥ì<br>
  (C++ì˜ hpp ê°™ì´ 'í‘œì¤€ í™•ì¥ì'ëŠ” ì•„ë‹˜)<br>

- ì‚¬ìš©ì²˜?<br>
  : ê³µìš© ìƒìˆ˜ ë²„í¼ ì •ì˜, ë°˜ë³µ ì‚¬ìš© í•¨ìˆ˜, êµ¬ì¡°ì²´ ì •ì˜ ë“±ì„ í¬í•¨ì‹œí‚¨ë‹¤<br>

- Item Type(í•­ëª© í˜•ì‹)ì„<br>
  : Does not participate in build (ë¹Œë“œì— ì°¸ì—¬ ì•ˆí•¨)<br>
   ìœ¼ë¡œ ì„¤ì •í•´ì•¼ í•œë‹¤<br>
   (ì•„ë‹ˆë©´ 'ë©”ì¸ í•¨ìˆ˜'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ë‹¤ëŠ” ì—ëŸ¬ ë°œìƒ)<br>
   (ê·¸ë ‡ì§€ë§Œ ì‰ì´ë”ê°€ ì•„ë‹ˆë¯€ë¡œ, main í•¨ìˆ˜ ê°™ì€ ì§„ì…ì ì´ ìˆìœ¼ë©´ ì•ˆë¨)<br>

ì˜ˆì‹œ íŒŒì¼<br>

```
// ì‰ì´ë”ì—ì„œ includeí•  ë‚´ìš©ë“¤ì€ .hlsli íŒŒì¼ì— ì‘ì„±
// Properties -> Item Type: Does not participate in buildìœ¼ë¡œ ì„¤ì •

#define MAX_LIGHTS 3 // ì‰ì´ë”ì—ì„œë„ #define ì‚¬ìš© ê°€ëŠ¥
#define NUM_DIR_LIGHTS 1
#define NUM_POINT_LIGHTS 1
#define NUM_SPOT_LIGHTS 1

// ì¬ì§ˆ
struct Material
{
    float3 ambient;
    float shininess;
    float3 diffuse;
    float dummy1; // 16 bytes ë§ì¶°ì£¼ê¸° ìœ„í•´ ì¶”ê°€
    float3 specular;
    float dummy2;
};

// ì¡°ëª…
struct Light
{
    float3 strength;
    float fallOffStart;
    float3 direction;
    float fallOffEnd;
    float3 position;
    float spotPower;
};

float CalcAttenuation(float d, float falloffStart, float falloffEnd)
{
    // Linear falloff
    return saturate((falloffEnd - d) / (falloffEnd - falloffStart));
}

...

struct VertexShaderInput
{
    float3 posModel : POSITION; //ëª¨ë¸ ì¢Œí‘œê³„ì˜ ìœ„ì¹˜ position
    float3 normalModel : NORMAL; // ëª¨ë¸ ì¢Œí‘œê³„ì˜ normal    
    float2 texcoord : TEXCOORD0; // <- ë‹¤ìŒ ì˜ˆì œì—ì„œ ì‚¬ìš©
    
    // float3 color : COLOR0; <- ë¶ˆí•„ìš” (ì‰ì´ë”©)
};

struct PixelShaderInput
{
    float4 posProj : SV_POSITION; // Screen position
    float3 posWorld : POSITION; // World position (ì¡°ëª… ê³„ì‚°ì— ì‚¬ìš©)
    float3 normalWorld : NORMAL;
    float2 texcoord : TEXCOORD;
    
    // float3 color : COLOR; <- ë¶ˆí•„ìš” (ì‰ì´ë”©)
};
```

ì‹¤ì œ ì‰ì´ë” íŒŒì¼ì—ì„œ ì‚¬ìš©í• ë•ŒëŠ”<br>

```
#include "Common.hlsli" // ì‰ì´ë”ì—ì„œë„ include ì‚¬ìš© ê°€ëŠ¥
```

ì´ëŸ°ì‹ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤<br>

### [unroll] í‚¤ì›Œë“œ?
ì¼ì¢…ì˜ 'ì†ì„±'(Attribute)ì´ë©°<br>
GPU ì‰ì´ë” ì»´íŒŒì¼ëŸ¬ê°€ forë¬¸ì„ ìµœì í™” í• ë•Œ<br>
ì»´íŒŒì¼ëŸ¬ì—ê²Œ 'ë°˜ë³µë¬¸'ì„ í’€ì–´<br>
í•˜ë“œì½”ë”©í•˜ë¼ê³  ì¡°ì–¸í•˜ëŠ” í‚¤ì›Œë“œ<br>

'ìƒìˆ˜'ì˜ ê°œìˆ˜ë¥¼ ê°€ì§€ëŠ” ë£¨í”„ ë¬¸ì¼ë•Œ<br>
ë” íš¨ê³¼ì (ì˜¤ë²„í—¤ë“œ x)<br>
(ë¬¼ë¡  ì‚¬ìš©í•˜ì§€ ì•Šë”ë¼ë„ ì»´íŒŒì¼ëŸ¬ê°€ ì•Œì•„ì„œ<br>
ìµœì í™”í• ìˆ˜ë„ ìˆìŒ)<br>

[HLSL forë¬¸ ê´€ë ¨](https://learn.microsoft.com/ko-kr/windows/win32/direct3dhlsl/dx-graphics-hlsl-for){:target="_blank" rel="noopener noreferrer"}<br>

```
float4 main(PixelShaderInput input) : SV_TARGET
{
    float3 toEye = normalize(eyeWorld - input.posWorld);

    float3 color = float3(0.0, 0.0, 0.0);
    
    int i = 0;
    
    // https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-for
    // https://forum.unity.com/threads/what-are-unroll-and-loop-when-to-use-them.1283096/
    
    [unroll] // warning X3557: loop only executes for 1 iteration(s), forcing loop to unroll
    for (i = 0; i < NUM_DIR_LIGHTS; ++i)
    {
        color += ComputeDirectionalLight(lights[i], material, input.normalWorld, toEye);
    }
    
    // ì»´íŒŒì¼ëŸ¬ì—ê²Œ í•˜ë“œ ì½”ë”©ì„ í•˜ë„ë¡ ê¶Œì¥
    // ë°˜ë³µë¬¸ì„ í’€ì–´í—¤ì¹˜ë„ë¡ ë§Œë“¤ì–´ë²„ë¦¼
    // ê°œìˆ˜ê°€ 'ìƒìˆ˜'ë¼ë©´ íš¨ê³¼ì 
    // ì´ëŸ°ê±¸ Attributeë¼ í•¨
    [unroll]
    for (i = NUM_DIR_LIGHTS; i < NUM_DIR_LIGHTS + NUM_POINT_LIGHTS; ++i)
    {
        color += ComputePointLight(lights[i], material, input.posWorld, input.normalWorld, toEye);
    }
    [unroll]
    for (i = NUM_DIR_LIGHTS + NUM_POINT_LIGHTS; i < NUM_DIR_LIGHTS + NUM_POINT_LIGHTS + NUM_SPOT_LIGHTS; ++i)
    {
        color += ComputeSpotLight(lights[i], material, input.posWorld, input.normalWorld, toEye);
    }
    return useTexture ? float4(color, 1.0) * g_texture0.Sample(g_sampler, input.texcoord) : float4(color, 1.0);
}
```