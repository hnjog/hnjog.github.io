---
title: "ê¹€í•˜ì—° íŠœí„°ë‹˜ ê°•ì˜ - 'GAS ì•„í‚¤í…ì³ - GASê°€ ëŒì•„ê°€ëŠ” í° ê·¸ë¦¼ ì´í•´í•˜ê¸°'"
date : "2025-12-08 12:00:00 +0900"
last_modified_at: "2025-12-08T12:00:00"
categories:
  - Unreal
  - C++
tags:
  - Unreal
  - C++
  - Actor
  - Subsystem
---

# GAS ì•„í‚¤í…ì³ì— ëŒ€í•˜ì—¬ ì•Œì•„ë³´ì

ê¹€í•˜ì—° íŠœí„°ë‹˜ì˜ Notion ìë£Œë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°•ì˜ë¥¼ ë“¤ìœ¼ë©°<br>
ìˆ˜ì • ë° ì¬ì‘ì„±í•œ ë¸”ë¡œê¹…ìš© ê¸€<br>

- GASëŠ” ì†Œê·œëª¨ ê²Œì„ë³´ë‹¨<br>
  ëŒ€ê·œëª¨ ê²Œì„ ê¸°ë°˜ì„<br>
  - ì´ˆê¸° ì„¤ì • ë° í•™ìŠµ ë‚œì´ë„ê°€ ë†’ì€ í¸<br>
  - ë˜í•œ, ì—°ì‚°ëŸ‰ì´ ë‚®ì§€ ì•ŠìŒ<br>

- GASì˜ ì¥ì ì€ í™•ì¥ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±!<br>
  - ì˜¤ë²„ ì—”ì§€ë‹ˆì–´ë§ì—ëŠ” ìœ ì˜í•˜ì<br>

# 1. GAS ì˜ 5ëŒ€ ìš”ì†Œ ğŸ‰

## 1-1. Gameplay Ability System (GAS)ë€?

- Epic Gamesê°€ í¬íŠ¸ë‚˜ì´íŠ¸ ê°œë°œ ê³¼ì •ì—ì„œ ë§Œë“  ì‹œìŠ¤í…œ<br>
- ìŠ¤í‚¬, ë²„í”„, ë””ë²„í”„, ëŠ¥ë ¥ì¹˜ë¥¼ **ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ì „íˆ¬ í”„ë ˆì„ì›Œí¬**<br>
- ì „í†µì ì¸ RPG ìºë¦­í„° ì‹œíŠ¸ë¥¼ ì—”ì§„ ìˆ˜ì¤€ì—ì„œ êµ¬ì¡°í™”í•œ ì‹œìŠ¤í…œ<br>

```
[ë””ì§€í„¸ TRPG ìºë¦­í„° ì‹œíŠ¸ êµ¬ì¡°]

1. ê´€ë¦¬ì (DM)  â” Ability System Component (ASC)
2. ëŠ¥ë ¥ì¹˜ (Stats) â” Attribute Set
3. í–‰ë™ (Actions) â” Gameplay Ability (GA)
4. ê²°ê³¼/ë³€í™” (Changes) â” Gameplay Effect (GE)
---------------------------------------------------
5. ì–¸ì–´/ê·œì¹™ (Language) â” Gameplay Tags
```

## 1-2. Ability System Component (ASC) - ì§€íœ˜ê´€

- ASCëŠ” `GASì˜ ëª¨ë“  êµ¬ì„± ìš”ì†Œë¥¼ ì´ê´„í•˜ê³  ê´€ë¦¬`í•˜ëŠ” ì¤‘ì•™ ì²˜ë¦¬ ì¥ì¹˜<br>
- ìºë¦­í„°ê°€ ìˆ˜í–‰í•˜ëŠ” `ëª¨ë“  í–‰ë™`(Ability), `ìƒíƒœ ë³€í™”`(Effect), `ëŠ¥ë ¥ì¹˜`(Attribute)ëŠ” ë°˜ë“œì‹œ ASCë¥¼ ê±°ì³ì„œ ì²˜ë¦¬ë¨.<br>

### ì‘ë™ ì›ë¦¬

ê³¼ê±°ì˜ ì§ì ‘ì ì¸ í•¨ìˆ˜ í˜¸ì¶œ(`Call Function`) ë°©ì‹ì—ì„œ ë²—ì–´ë‚˜,<br>
íƒœê·¸(Tag)ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ëŠìŠ¨í•œ ê²°í•©(Loose Coupling) ë°©ì‹ì„ ì‚¬ìš©í•¨.<br>

```graphql
[ í”Œë ˆì´ì–´ ì…ë ¥ (Enhanced Input) ]
         â”‚
         â”‚ (Input Tag ì „ë‹¬: "ë‚˜ ìŠ¤í‚¬ ì“¸ë˜!")
         â–¼
[ ASC (ì‹¬ì¥ & ê´€ì œíƒ‘) ]
         â”‚
         â”‚ (1. íƒœê·¸ & ìƒíƒœ í™•ì¸: "ì§€ê¸ˆ ì  ìˆ˜ ìˆë‚˜?")
         â–¼
    â”Œâ”€â”€â”€< íŒë‹¨ >â”€â”€â”€â”
    â”‚              â”‚
    â–¼ (No)         â–¼ (Yes)
 [ ì‹¤íŒ¨ ]       [ Ability ì‹¤í–‰ (Activate) ]
(ê¸°ì ˆ/ì¿¨íƒ€ì„)      â”‚
                   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â–¼                       â–¼
           [ ë¹„ìš©/ì¿¨íƒ€ì„ ì ìš© ]      [ ì´í™íŠ¸(GE) ì ìš© ]
           (ë§ˆë‚˜ ì°¨ê°, ì¿¨ ì‹œì‘)    (ë°ë¯¸ì§€ ê³„ì‚° ë° ì „ë‹¬)
                   â”‚                       â”‚
                   â–¼                       â–¼
           [ Attribute Set ]       [ Target (ì ) ]
           (ë‚´ ìŠ¤íƒ¯ ë³€í™”)          (ìƒëŒ€ ì²´ë ¥ ê°ì†Œ)
```

1. Input Tag ì „ë‹¬: í”Œë ˆì´ì–´ì˜ ì…ë ¥ì€ `Input.Action.Skill` ê°™ì€ íƒœê·¸ í˜•íƒœë¡œ ASCì— ì „ë‹¬<br>

2. ê·œì¹™ ê²€ì‚¬ (Policy Check): ASCëŠ” í˜„ì¬ ìºë¦­í„°ì˜ ìƒíƒœ(íƒœê·¸), ìì›(ë§ˆë‚˜), ì¿¨íƒ€ì„ì„ í™•ì¸<br>

3. ì‹¤í–‰ ë° ë™ê¸°í™”: ì¡°ê±´ì´ ì¶©ì¡±ë˜ë©´ ë¡œì§ì„ ìˆ˜í–‰í•˜ê³ , ê²°ê³¼ë¥¼ ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì— ì „íŒŒí•¨.<br>

### í•µì‹¬ ì—­í•  ìƒì„¸

- `ê·œì¹™ ì§‘í–‰` (Rule Enforcement)<br>
    - ASCëŠ” ì–´ë¹Œë¦¬í‹° ì‹¤í–‰ ìš”ì²­ì´ ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ ë‹¤ìŒ 3ê°€ì§€ë¥¼ ê²€ì‚¬í•¨.<br>
        - Can Activate: í˜„ì¬ ìƒíƒœì—ì„œ **ì‹¤í–‰ ê°€ëŠ¥í•œê°€?** (ì˜ˆ: ê³µì¤‘ì—ì„œ ì‚¬ìš© ë¶ˆê°€)<br>
        - Cost Check: **í•„ìš”í•œ ìì›**ì´ ìˆëŠ”ê°€? (ì˜ˆ: ë§ˆë‚˜ 50 ì†Œëª¨)<br>
        - Cooldown Check: **ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„**ì´ ëë‚¬ëŠ”ê°€?<br>
- `ë„¤íŠ¸ì›Œí¬ ì¤‘ê°œ` (Replication Bridge)<br>
    - ë©€í‹°í”Œë ˆì´ì–´ í™˜ê²½ì—ì„œ **ë³µì¡í•œ ë™ê¸°í™” ì½”ë“œë¥¼ ì‘ì„±í•˜ì§€ ì•Šì•„ë„, ASCê°€ ì´ë¥¼ ëŒ€ì‹  ì²˜ë¦¬**<br>
        - `Client Prediction`: í´ë¼ì´ì–¸íŠ¸ì—ì„œ ë¨¼ì € **ì—°ì¶œì„ ì‹¤í–‰**í•˜ì—¬ ë°˜ì‘ì„±ì„ ë†’ì„.<br>
        - `Server Authority`: ì„œë²„ì—ì„œ ìµœì¢… `ê²€ì¦ í›„ ê²°ê³¼ë¥¼ í™•ì •`.<br>
        - `Automatic Replication`: ì–´ë¹Œë¦¬í‹° ì‹¤í–‰ ì—¬ë¶€ì™€ ì´í™íŠ¸ ì ìš© ê²°ê³¼ë¥¼ **ìë™ìœ¼ë¡œ ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ì— ì „íŒŒ**.<br>
- `ë°ë¯¸ì§€ ë° ì´í™íŠ¸ íŒŒì´í”„ë¼ì¸`<br>
    - ì™¸ë¶€ì—ì„œ ë“¤ì–´ì˜¤ëŠ” **ëª¨ë“  ë³€í™”**(ë°ë¯¸ì§€, í, ë²„í”„)ëŠ” **ASCë¥¼ í†µí•´ Gameplay Effect(GE) í˜•íƒœë¡œ ì²˜ë¦¬**ë¨.<br>
    - `TakeDamage()` í•¨ìˆ˜ ëŒ€ì‹  `ApplyGameplayEffectToTarget()`ì„ ì‚¬ìš©í•˜ì—¬, ë°©ì–´ë ¥ ê³„ì‚°ì´ë‚˜ ë¬´ì  íŒì • ë“±ì˜ ë¡œì§ì„ ì¼ê´€ì„± ìˆê²Œ ì²˜ë¦¬í•¨.<br>

## 1-3. Attribute Set - ì‚´ì•„ìˆëŠ” ëŠ¥ë ¥ì¹˜ ì‹œìŠ¤í…œ

- ê²Œì„ ë‚´ ìºë¦­í„°ì˜ ëŠ¥ë ¥ì¹˜ (Stats)ë¥¼ ì •ì˜í•˜ê³  ê´€ë¦¬í•˜ëŠ” ë°ì´í„° ì»¨í…Œì´ë„ˆ<br>
- ë‹¨ìˆœí•œ ë³€ìˆ˜ (float)ê°€ ì•„ë‹Œ, `FGameplayAttributeData` êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ ìˆ˜ì¹˜ì˜ ë³€í™” ë‚´ì—­, ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™”, ê³„ì‚° ë¡œì§ì„ í†µí•© ê´€ë¦¬<br>

### ê¸°ì¡´ ë°©ì‹(`float`) vs GAS ë°©ì‹ ë¹„êµ

| **êµ¬ë¶„** | **ì¼ë°˜ ë³€ìˆ˜ ë°©ì‹ (float Health)** | **GAS ë°©ì‹ (FGameplayAttributeData)** |
| --- | --- | --- |
| **êµ¬ì¡°** | ë‹¨ìˆœ ìˆ«ì ê°’ í•˜ë‚˜ë§Œ ì €ì¥ | BaseValueì™€ **CurrentValue** ë¶„ë¦¬ ì €ì¥ |
| **ìƒíƒœ ê´€ë¦¬** | ë²„í”„/ë””ë²„í”„ ì ìš© ì‹œ ì§ì ‘ ì—°ì‚° í•„ìš” | **Modifiers**ê°€ ìë™ìœ¼ë¡œ ê³„ì‚° ë° í•©ì‚° |
| **ë³µì›** | ë²„í”„ ì¢…ë£Œ ì‹œ ì›ìƒë³µêµ¬ ë¡œì§ êµ¬í˜„ í•„ìš” | **ìë™ ë³µêµ¬ (Dirty Marking)** |
| **ë„¤íŠ¸ì›Œí¬** | ë³„ë„ì˜ ë¦¬í”Œë¦¬ì¼€ì´ì…˜ í•¨ìˆ˜ í•„ìš” | **ìë™ ë™ê¸°í™” ë° ì˜ˆì¸¡(Prediction) ì§€ì›** |

### í•µì‹¬ êµ¬ì¡°: ë‘ ê°œì˜ í†µì¥ (Base vs Current)

```graphql
UPROPERTY(BlueprintReadOnly, ReplicateUsing = OnRep_Health)
FGameplayAttributeData Health;
```

GASì˜ ì†ì„±ì€ í•˜ë‚˜ì˜ ìŠ¤íƒ¯ì— ëŒ€í•´ ë‘ ê°€ì§€ ê°’ì„ ë™ì‹œì— ìœ ì§€í•¨.<br>

- BaseValue (**ê¸°ë³¸ê°’**): ìºë¦­í„°ì˜ `ì˜êµ¬ì ì¸ ëŠ¥ë ¥ì¹˜`. (ë ˆë²¨ì—…, ì˜êµ¬ ìŠ¤íƒ¯ ì•„ì´í…œ ë“±ìœ¼ë¡œë§Œ ë³€ê²½)<br>
- CurrentValue (**í˜„ì¬ê°’**): ëª¨ë“  ë²„í”„, ë””ë²„í”„, ì¥ë¹„ íš¨ê³¼ê°€ í•©ì‚°ëœ `ìµœì¢… ê°’`.<br>

### ë³€ê²½ ê·œì¹™ (Duration Policyì— ë”°ë¥¸ ì°¨ì´)

Gameplay Effect(GE)ì˜ **ì§€ì†ì„± ì •ì±…**ì— ë”°ë¼ ë³€ê²½ë˜ëŠ” ê°’ì´ ë‹¬ë¼ì§.<br>

| **GE ì¢…ë¥˜** | **ëŒ€ìƒ ê°’** | **ë™ì‘ ì›ë¦¬** | **ì˜ˆì‹œ** |
| --- | --- | --- | --- |
| **Instant** | **BaseValue** | ê°’ì„ ì˜êµ¬ì ìœ¼ë¡œ ë³€ê²½í•¨ | ë°ë¯¸ì§€(ì²´ë ¥ ê°ì†Œ), ì˜êµ¬ ìŠ¤íƒ¯ ìƒìŠ¹ ë¬¼ì•½ |
| **Duration** | **CurrentValue** | BaseValueëŠ” ìœ ì§€í•˜ê³ , Currentë§Œ ì ì‹œ ë³€ê²½ | 10ì´ˆê°„ ê³µê²©ë ¥ ì¦ê°€ ë²„í”„ |
| **Infinite** | **CurrentValue** | ì¥ë¹„ í•´ì œ ë“± íŠ¹ì • ì‹œì ê¹Œì§€ ê°’ ìœ ì§€ | ë¬´ê¸° ì¥ì°© ì‹œ ê³µê²©ë ¥ ì¦ê°€ |

> ë²„í”„(Duration)ê°€ ëë‚˜ë©´, GASëŠ” CurrentValueë¥¼ ë‹¤ì‹œ ê³„ì‚°í•¨. ë”°ë¼ì„œ ê°œë°œìê°€ "ë²„í”„ ëë‚¬ìœ¼ë‹ˆ -10 í•˜ì„¸ìš”"ë¼ëŠ” ì½”ë“œë¥¼ ì§¤ í•„ìš”ê°€ ì—†ë‹¤ëŠ” ì–˜ê¸°
> 

### ê³„ì‚° íŒŒì´í”„ë¼ì¸ (Calculation Pipeline)

GASëŠ” ìµœì¢… ê°’(CurrentValue)ì„ ê²°ì •í•  ë•Œ ì—„ê²©í•œ ìˆ˜í•™ì  ìˆœì„œë¥¼ ë”°ë¦…ë‹ˆë‹¤.<br>

$$
CurrentValue = (BaseValue + \sum Additive) \times \prod Multiplicative
$$

### ê³„ì‚° íë¦„ë„

```graphql
[BaseValue: 100] (ê¸°ë³¸ ê³µê²©ë ¥)
       â”‚
       â–¼
[1. Additive Modifiers] (ë”í•˜ê¸° ì—°ì‚° ëª¨ìŒ)
       â”‚ â”œâ”€ ë¬´ê¸° ê³µê²©ë ¥ (+50)
       â”‚ â””â”€ ë””ë²„í”„ (-20)
       â”‚ -> ì¤‘ê°„ í•©ê³„: 130
       â–¼
[2. Multiplicative Modifiers] (ê³±í•˜ê¸° ì—°ì‚° ëª¨ìŒ)
       â”‚ â”œâ”€ ë¶„ë…¸ ë²„í”„ (x 1.5)
       â”‚ â””â”€ ì•½í™” ì €ì£¼ (x 0.5)
       â”‚ -> 130 * 1.5 * 0.5
       â–¼
[CurrentValue: 97.5] (ìµœì¢… ê²°ê³¼)

UPROPERTY(BlueprintReadOnly, ReplicateUsing = OnRep_Health)
FGameplayAttributeData Health;
```

- ê·œì¹™: í•­ìƒ `ë§ì…ˆì„ ë¨¼ì € ëª¨ë‘ ìˆ˜í–‰`í•œ í›„, `ê·¸ ê²°ê³¼ì— ê³±ì…ˆ`ì„ ìˆ˜í–‰í•¨.<br>

### ë°ì´í„° ë¬´ê²°ì„± ë³´í˜¸ (Clamping)

ì²´ë ¥ì´ 0 ë¯¸ë§Œìœ¼ë¡œ ë–¨ì–´ì§€ê±°ë‚˜, ìµœëŒ€ ì²´ë ¥ì„ ì´ˆê³¼í•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ `PreAttributeChange` í•¨ìˆ˜ë¥¼ ì‚¬ìš©<br>

- ì‹œì : ì†ì„± ê°’ì´ ë³€ê²½ë˜ê¸° ì§ì „ì— í˜¸ì¶œë¨.<br>
- ì—­í• : ë“¤ì–´ì˜¤ëŠ” ê°’ì„ ê²€ì‚¬í•˜ê³ , ë²”ìœ„ ë‚´ë¡œ Clamp(ìë¥´ê¸°)<br>

## 1-4. Gameplay Ability (GA) - ì•¡ì…˜ì˜ ì •ì˜ì™€ íë¦„

- ìºë¦­í„°ê°€ ìˆ˜í–‰í•˜ëŠ” ëª¨ë“  `í–‰ë™` (Action)ê³¼ `ê¸°ìˆ ` (Skill)ì„ ì •ì˜í•˜ëŠ” í´ë˜ìŠ¤<br>
- ë‹¨ìˆœí•œ í•¨ìˆ˜ í˜¸ì¶œì´ ì•„ë‹ˆë¼, **ìƒíƒœì™€ ì‹œê°„ì„ ê°€ì§€ê³  ì‹¤í–‰ë˜ëŠ” ê°ì²´**<br>

### ìƒëª…ì£¼ê¸° (Lifecycle)

GAëŠ” ì—„ê²©í•œ ì‹¤í–‰ ìˆœì„œë¥¼ ë”°ë¥´ë©°,<br>
ëª¨ë“  ë‹¨ê³„ê°€ í†µê³¼ë˜ì–´ì•¼ ì‹¤í–‰ë©ë‹ˆë‹¤.<br>

```
[1. TryActivate] (ìš”ì²­)
       â”‚
       â–¼
[2. CanActivate] (ê²€ì‚¬: ì…êµ­ ì‹¬ì‚¬)
       â”‚ - ë§ˆë‚˜/ì¿¨íƒ€ì„ í™•ì¸
       â”‚ - Tag í™•ì¸ (ê¸°ì ˆ ìƒíƒœ? ë¬´ê¸° ì¥ì°©?)
       â”‚
       â–¼ (Pass)
[3. CommitAbility] (ê²°ì œ: ë¹„ìš© ì§€ë¶ˆ)
       â”‚ - Cost ì°¨ê° (ë§ˆë‚˜)
       â”‚ - Cooldown ì ìš©
       â”‚
       â–¼
[4. ActivateAbility] (ì‹¤í–‰: ë³¸ ë¡œì§)
       â”‚ â˜… í•µì‹¬ êµ¬ê°„ (Ability Task ì‹¤í–‰)
       â”‚
       â–¼
[5. EndAbility] (ì¢…ë£Œ: ë’·ì •ë¦¬)
       â”‚ - ë©”ëª¨ë¦¬ í•´ì œ
       â”‚ - Tag ì œê±°
```

### í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜: Ability Task (ì‹œê°„ ì œì–´)

- GAê°€ ë‹¨ìˆœ í•¨ìˆ˜ì™€ ë‹¤ë¥¸ ê°€ì¥ í° ì°¨ì´ì ì€ `ë¹„ë™ê¸° ëŒ€ê¸°`(Latent Wait)ê°€ ê°€ëŠ¥í•˜ë‹¤ëŠ” ì <br>
- ì´ë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ `Ability Task`<br>

### Abilityì™€ Taskì˜ ê´€ê³„

- ë¬¸ì œì : GAëŠ” `Activate()` í˜¸ì¶œ í›„ ì½”ë“œê°€ ëë‚˜ë©´ ì¦‰ì‹œ ì†Œë©¸(`End`)í•˜ë ¤ í•¨.<br>
- í•´ê²°ì±…: **Taskê°€ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ** GAì˜ *ì¢…ë£Œë¥¼ ë§‰ê³ *, íŠ¹ì • ì‚¬ê±´(ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ, ì…ë ¥ í•´ì œ ë“±)ì´ *ë°œìƒí•  ë•Œê¹Œì§€ ëŒ€ê¸°*í•¨.<br>
    â†’ AbilityëŠ” ê»ë°ê¸°(Container)ì´ê³ , TaskëŠ” ê·¸ ì•ˆì—ì„œ ì‹œê°„ì„ ì†Œë¹„í•˜ëŠ” ì—”ì§„(Engine)<br>
    
### êµ¬í˜„ íŒ¨í„´ (Patterns)

ì‚¬ìš©í•˜ëŠ” **Task**ì˜ ì¢…ë¥˜ì— ë”°ë¼ ìŠ¤í‚¬ì˜ ì„±ê²©ì´ ê²°ì •ë¨.<br>

| **ìœ í˜•** | **ì„¤ëª…** | **í•µì‹¬ Task** | **ì˜ˆì‹œ** |
| --- | --- | --- | --- |
| **Active** | ì¦‰ì‹œ ì‹¤í–‰ í›„ ì¢…ë£Œ | `PlayMontageAndWait` | ê³µê²©, ì í”„, ìŠ¤í‚¬ ì‚¬ìš© |
| **Interaction** | íŠ¹ì • ì…ë ¥/ì‹œê°„ ë™ì•ˆ ìœ ì§€ | `WaitInputRelease` | ì°¨ì§• ê³µê²©, ë¶€í™œì‹œí‚¤ê¸° |
| **Passive** | ê²Œì„ ë‚´ë‚´ ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ | `WaitAttributeChange` | ì²´ë ¥ 30% ì´í•˜ ì‹œ ë°©ì–´ ë²„í”„ |

### ë©”ëª¨ë¦¬ ìµœì í™” (Instancing Policy)

***GAë¥¼ ë©”ëª¨ë¦¬ì— ì–´ë–»ê²Œ ìƒì„±***í• ì§€ ê²°ì •í•˜ëŠ” ì¤‘ìš”í•œ ìµœì í™” ì˜µì…˜ì„.<br>

1. `Instanced Per Actor` (ê¸°ë³¸ê°’)<br>
    - ìºë¦­í„°ë§ˆë‹¤ *ë³„ë„ì˜ GA ê°ì²´ ìƒì„±*.<br>
    - *ë³µì¡í•œ ë¡œì§, ë³€ìˆ˜ ì €ì¥*ì´ í•„ìš”í•œ ìŠ¤í‚¬ì— ì‚¬ìš©.<br>
2. `Non-Instanced` (ìµœì í™”)<br>
    - *ëª¨ë“  ìºë¦­í„°ê°€ í•˜ë‚˜ì˜ GA ê°ì²´(CDO)ë¥¼ ê³µìœ *.<br>
    - ë³€ìˆ˜ë¥¼ ì €ì¥í•  ìˆ˜ ì—†ìœ¼ë‚˜ ë©”ëª¨ë¦¬ ë¹„ìš©ì´ ë§¤ìš° ë‚®ìŒ.<br>
    - *ë‹¨ìˆœí•œ í‰íƒ€, ì í”„* ë“±ì— ê¶Œì¥ (í¬íŠ¸ë‚˜ì´íŠ¸ ë°©ì‹).<br>

## 1-5. Gameplay Effect (GE) - ë³€í™”ë¥¼ ì •ì˜í•˜ëŠ” ë°ì´í„°

- ê²Œì„ ë‚´ì—ì„œ ë°œìƒí•˜ëŠ” ëª¨ë“  **ì†ì„± (Attribute)ì˜ ë³€ê²½**ê³¼ **ìƒíƒœ (State) ë³€í™”**ë¥¼ `ì •ì˜`í•˜ëŠ” ë°ì´í„° ì—ì…‹<br>
- ë¸”ë£¨í”„ë¦°íŠ¸ ë¡œì§ì´ë‚˜ C++ ì½”ë“œê°€ ì•„ë‹Œ, *ìˆœìˆ˜ ë°ì´í„° (Data Asset) í˜•íƒœë¡œ ì¡´ì¬*í•˜ë©°, ASCì— ì˜í•´ í•´ì„ë˜ê³  ì‹¤í–‰<br>

### GEì˜ íŠ¹ì§•: ë°ì´í„° ê¸°ë°˜ ì„¤ê³„ (Data-Driven)

Gameplay EffectëŠ” í”„ë¡œê·¸ë˜ë°(Logic)ì´ ì•„ë‹Œ ì„¤ì •(Configuration)ì˜ ì˜ì—­<br>

- ê¸°íšìê°€ í”„ë¡œê·¸ë˜ë¨¸ ì—†ì´ ìˆ˜ì¹˜ ì¡°ì • ê°™ì€ ë°¸ëŸ°ìŠ¤ ì‘ì—…ì„ í•˜ê¸° ìœ„í•´<br>

| **êµ¬ë¶„** | **ì¼ë°˜ì ì¸ êµ¬í˜„ ë°©ì‹** | **GAS êµ¬í˜„ ë°©ì‹ (GE)** |
| --- | --- | --- |
| **êµ¬í˜„ ë°©ë²•** | C++ / BP í•¨ìˆ˜ (`TakeDamage`) ì‘ì„± | **ë°ì´í„° ì—ì…‹(`GE_Damage`) ìƒì„± ë° ìˆ˜ì¹˜ ì…ë ¥** |
| **í¸ì§‘ í™˜ê²½** | ë…¸ë“œ ê·¸ë˜í”„ ë˜ëŠ” ì½”ë“œ ì—ë””í„° | **ë””í…Œì¼ íŒ¨ë„ (ì†ì„± ì°½)** |
| **ì‘ì—… ì£¼ì²´** | í”„ë¡œê·¸ë˜ë¨¸ | **ê¸°íšì (ë°¸ëŸ°ìŠ¤ ì¡°ì • ìš©ì´)** |
| **ìœ ì§€ ë³´ìˆ˜** | ìˆ˜ì¹˜ ë³€ê²½ ì‹œ ì»´íŒŒì¼/ì¬ì €ì¥ í•„ìš” | **ì—ì…‹ ê°’ë§Œ ìˆ˜ì •í•˜ë©´ ì¦‰ì‹œ ë°˜ì˜** |

### í•µì‹¬ ì„¤ì • ìš”ì†Œ (Configuration)

- `ì§€ì†ì„± ì •ì±…` (Duration Policy): ì´ íš¨ê³¼ê°€ ì†ì„±ì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ì‹œê°„ì  ê·œì¹™ì„ ì •ì˜<br>

| **ì •ì±… (Policy)** | **ì„¤ëª…** | **ì†ì„± ì˜í–¥** | **ì˜ˆì‹œ** |
| --- | --- | --- | --- |
| **Instant** | ì¦‰ì‹œ ì ìš©ë˜ê³  ì¢…ë£Œë¨ | **BaseValue** ì˜êµ¬ ë³€ê²½ | ë°ë¯¸ì§€, ì¦‰ì‹œ íšŒë³µ |
| **Duration** | ì •í•´ì§„ ì‹œê°„(`X`ì´ˆ) ë™ì•ˆë§Œ ìœ ì§€ë¨ | **CurrentValue** ì„ì‹œ ë³€ê²½ | ì´ë™ì†ë„ ë²„í”„, ë„íŠ¸ ë°ë¯¸ì§€ |
| **Infinite** | ë³„ë„ì˜ ì œê±° ëª…ë ¹ ì „ê¹Œì§€ ì˜êµ¬ ìœ ì§€ | **CurrentValue** ì„ì‹œ ë³€ê²½ | ì¥ë¹„ ì°©ìš© ìŠ¤íƒ¯, ì˜êµ¬ ìƒíƒœì´ìƒ |


- `ìˆ˜ì¹˜ ë³€ê²½ ì—°ì‚°` (Modifiers): ì†ì„± ê°’ì„ ì–´ë–»ê²Œ ë³€ê²½í• ì§€ ìˆ˜í•™ì  ì—°ì‚°ì„ ì •ì˜<br>
    - **Attribute:** ë³€ê²½í•  ì†ì„± ì„ íƒ (ì˜ˆ: `Health`, `Mana`)<br>
    - **Operation:** ì—°ì‚° ë°©ì‹ ì„ íƒ<br>
        - **Add:** ë”í•˜ê¸° (ë°ë¯¸ì§€ëŠ” ìŒìˆ˜ ê°’ì„ ë”í•¨)<br>
        - **Multiply:** ê³±í•˜ê¸° (ë¹„ìœ¨ í¼ì„¼íŠ¸ ì ìš©)<br>
        - **Override:** ë®ì–´ì“°ê¸° (íŠ¹ì • ê°’ìœ¼ë¡œ ê³ ì •)<br>
    - **Value:** ì ìš©í•  ìˆ˜ì¹˜ ì…ë ¥ (ì˜ˆ: `10.0`)<br>

### ëª¨ë“ˆí˜• í™•ì¥

UE 5.5ë¶€í„° GEëŠ” `ì»´í¬ë„ŒíŠ¸ ì¡°ë¦½` ë°©ì‹(Modular)ìœ¼ë¡œ ê¸°ëŠ¥ì„ í™•ì¥ë¨.<br>

- Target Tags: íš¨ê³¼ ì ìš© ì‹œ íŠ¹ì • íƒœê·¸ ë¶€ì°© (ì˜ˆ: `State.Debuff.Poison`).<br>
- Grant Abilities: íš¨ê³¼ ì ìš© ì¤‘ íŠ¹ì • ì–´ë¹Œë¦¬í‹° ë¶€ì—¬ (ì˜ˆ: ë…ì— ê±¸ë¦¬ë©´ 'í•´ë…' ìŠ¤í‚¬ ì‚¬ìš© ê°€ëŠ¥).<br>
- Immunity: íŠ¹ì • íš¨ê³¼ì— ëŒ€í•œ ë©´ì—­ ë¶€ì—¬.<br>

### ì´ ì™¸ ê³ ê¸‰ ê¸°ëŠ¥ (Automation)

- ë³µì¡í•œ ê²Œì„ ë¡œì§ì„ ì½”ë“œ ì—†ì´ *ì˜µì…˜ ì„¤ì •ë§Œìœ¼ë¡œ êµ¬í˜„*í•©ë‹ˆë‹¤.<br>
    - Period (ì£¼ê¸°ì  ì‹¤í–‰): `Duration` ì‹œê°„ ë™ì•ˆ `X`ì´ˆë§ˆë‹¤ íš¨ê³¼ë¥¼ ë°˜ë³µ ì‹¤í–‰<br>
    - Stacking (ì¤‘ì²©): ë™ì¼í•œ íš¨ê³¼ê°€ ì—¬ëŸ¬ ë²ˆ ì ìš©ë  ë•Œì˜ ê·œì¹™ ì„¤ì •.<br>
        - Stack Limit (ìµœëŒ€ ì¤‘ì²© ìˆ˜)<br>
        - Duration Refresh (ì‹œê°„ ê°±ì‹  ì—¬ë¶€)<br>
        - Expiration Policy (ë§Œë£Œ ì‹œ ì²˜ë¦¬)<br>

## 1-6. Gameplay Tags - ì‹œìŠ¤í…œì„ ì§€ë°°í•˜ëŠ” ê³µìš©ì–´

- GAS ë‚´ì—ì„œ **ê°ì²´ì˜ ìƒíƒœ(State)ë¥¼ ì •ì˜**í•˜ê³ , ì‹œìŠ¤í…œ ê°„ì˜ *ìƒí˜¸ì‘ìš© ê·œì¹™ì„ ê²°ì •*í•˜ëŠ” **í‘œì¤€ ì‹ë³„ì**<br>
- ê¸°ì¡´ì˜ 'boolean ë³€ìˆ˜ë‚˜ Enumì„ ëŒ€ì²´'í•˜ë©°, `ê³„ì¸µí˜• êµ¬ì¡°(Hierarchy)`ë¡œ ì´ë£¨ì–´ì§.<br>

### íƒœê·¸ì˜ êµ¬ì¡° (Hierarchy)

íƒœê·¸ëŠ” ì (.)ìœ¼ë¡œ êµ¬ë¶„ëœ ê³„ì¸µ êµ¬ì¡°ë¥¼ ê°€ì§.<br>

- í˜•ì‹: `Category.SubCategory.Specific`<br>
- ì˜ˆì‹œ<br>

```cpp
State
    â”œâ”€â”€ Debuff
    â”‚    â”œâ”€â”€ Stun   (ê¸°ì ˆ)
    â”‚    â””â”€â”€ Freeze (ë¹™ê²°)
    â””â”€â”€ Buff
        â””â”€â”€ Speed  (ê°€ì†)
```

- ìƒíƒœ ì´ìƒì— ê±¸ë¦¬ì§€ ì•Šì•˜ëŠ”ì§€ ê²€ì‚¬?<br>

```cpp
if(!bStunned ||
   !bFrozen ||
   ...)
```

### ê¸°ì¡´ ë°©ì‹ vs GAS íƒœê·¸ ë°©ì‹

| **êµ¬ë¶„** | **Boolean ë°©ì‹ (ê¸°ì¡´)** | **Gameplay Tag ë°©ì‹ (GAS)** |
| --- | --- | --- |
| **ìƒíƒœ ê´€ë¦¬** | `bIsStunned`, `bIsFrozen` ë“± ë³€ìˆ˜ ë‚˜ì—´ | `State.Debuff.Stun` íƒœê·¸ í•˜ë‚˜ë¡œ ê´€ë¦¬ |
| **ìœ ì§€ ë³´ìˆ˜** | ìƒíƒœ ì¶”ê°€ ì‹œ ì½”ë“œ ìˆ˜ì • í•„ìˆ˜ | **ë°ì´í„° ì¶”ê°€ë§Œìœ¼ë¡œ í•´ê²° (ì½”ë“œ ìˆ˜ì • X)** |

### í•µì‹¬ ê¸°ëŠ¥: ê³„ì¸µ ë§¤ì¹­ (Hierarchy Matching)

ë¶€ëª¨ íƒœê·¸ë¥¼ ê²€ì‚¬í•˜ë©´ `ìì‹ íƒœê·¸ê°€ ìë™ìœ¼ë¡œ í¬í•¨`ë˜ëŠ” ê¸°ëŠ¥<br>

- ê²€ì‚¬: ì´ ìºë¦­í„°ê°€ `State.Debuff` ìƒíƒœì¸ê°€?<br>
- ë³´ìœ : `State.Debuff.Stun` (ìì‹) ë³´ìœ  ì¤‘<br>
- ê²°ê³¼: True (ë§¤ì¹­ ì„±ê³µ)<br>
    - *ëª¨ë“  ì¢…ë¥˜ì˜ ë””ë²„í”„ë¥¼ ì¼ì¼ì´ ë‚˜ì—´í•  í•„ìš” ì—†ì´, ë¶€ëª¨ íƒœê·¸ í•˜ë‚˜ë¡œ ì¼ê´„ ì²˜ë¦¬ê°€ ê°€ëŠ¥*<br>

### ì–´ë¹Œë¦¬í‹° ì œì–´ (Interaction)

ì½”ë”© ì—†ì´ íƒœê·¸ ì„¤ì •ë§Œìœ¼ë¡œ ìŠ¤í‚¬ ê°„ì˜ ì·¨ì†Œ(Cancel)ì™€ ì°¨ë‹¨(Block) ê·œì¹™ì„ ì •ì˜<br>

| **ê¸°ëŠ¥** | **ì„¤ëª…** | **ì˜ˆì‹œ ìƒí™©** |
| --- | --- | --- |
| **Cancel** | ì´ íƒœê·¸ê°€ ìˆëŠ” í–‰ë™ì„ **ê°•ì œ ì¢…ë£Œ**ì‹œí‚´ | **êµ¬ë¥´ê¸°** ì‚¬ìš© ì‹œ â†’ **ìºìŠ¤íŒ…(Casting)** ì¤‘ì¸ ë§ˆë²• ì·¨ì†Œ |
| **Block** | ì´ íƒœê·¸ê°€ ìˆëŠ” ë™ì•ˆ **í–‰ë™ ë¶ˆê°€** | **ê¸°ì ˆ(Stun)** ìƒíƒœì¼ ë•Œ â†’ **ê³µê²©(Attack)** ì‹œë„ ì°¨ë‹¨ |

### ì…ë ¥ íƒœê·¸ (Input Tag)

ìš”ì¦˜ì€ ì…ë ¥ ì‹œìŠ¤í…œ(Enhanced Input)ê³¼ GASë¥¼ íƒœê·¸ë¡œ ì—°ê²°í•¨.<br>

- ê°œë…: ë¬¼ë¦¬ì  í‚¤(Key)ê°€ ì§ì ‘ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³ , Input Tagë¥¼ ASCì— ì „ë‹¬í•˜ì—¬ ì–´ë¹Œë¦¬í‹°ë¥¼ íŠ¸ë¦¬ê±°<br>
- íë¦„: `Q Key` ì…ë ¥ â†’ `Input.Action.Heal` íƒœê·¸ ë°œìƒ â†’ `GA_Potion` ì‹¤í–‰<br>
  (í‚¤ ë³€ê²½ ê³¼ ê°™ì€ ì„¤ì • ì„¸íŒ…ì— ìœ ë¦¬)<br>

Tagë¥¼ ëª½íƒ€ì£¼ì™€ ì—°ê²°í•˜ì—¬<br>
íŠ¹ì • ë¶€ë¶„ì— 'ë¬´ì 'íš¨ê³¼ ë“±ì„ ë¶€ì—¬í•  ìˆ˜ë„ ìˆìŒ!<br>

## 1-7. GAS 5ëŒ€ ìš”ì†Œì˜ í˜‘ë ¥ ê³¼ì • (Data Flow)

```
[1. Input (ì…ë ¥)]
       â”‚
       â”‚ (Input Tag: "Input.Action.Heal")
       â–¼
[2. ASC (ì¤‘ì•™ ê´€ë¦¬ì)] â—€â”€â”€â”€ [Tag & Attribute ê²€ì‚¬]
       â”‚                    (ë§ˆë‚˜ ì¶©ë¶„? ê¸°ì ˆ ìƒíƒœ ì•„ë‹˜?)
       â”‚ (ìŠ¹ì¸: Activate)
       â–¼
[3. Ability (í–‰ë™ ì‹¤í–‰)]
       â”‚
       â”œâ”€ (â“ Commit) â”€â”€â–¶ [Cost & Cooldown GE ì ìš©]
       â”‚
       â”‚ (â“‘ Ability Task: ì‹œê°„ ì§€ì—°)
       â–¼
[4. Animation (ëª½íƒ€ì£¼ ì¬ìƒ & ëŒ€ê¸°)]
       â”‚
       â”‚ (â“’ ì™„ë£Œ ì‹œ: OnCompleted)
       â–¼
[5. Gameplay Effect (ë°ì´í„° ìƒì„±)]
       â”‚
       â”‚ (SpecHandle ì „ë‹¬: "Health +50")
       â–¼
[6. Attribute Set (ìˆ˜ì¹˜ ë°˜ì˜)]
       â”‚
       â”‚ (BaseValue ë³€ê²½ & Clamping)
       â–¼
[7. UI / Networking (ê²°ê³¼)]
       â”‚
       â””â”€â–¶ [ì²´ë ¥ë°” ê°±ì‹  (OnRep/Delegate)]
```

### **íë§ í¬ì…˜ ì‚¬ìš© ì˜ˆì‹œ**

í”Œë ˆì´ì–´ê°€ 'Q' í‚¤ë¥¼ ëˆŒëŸ¬ í¬ì…˜ì„ ë§ˆì‹œëŠ” 0.1ì´ˆ ë™ì•ˆì˜ ë‚´ë¶€ ì²˜ë¦¬ ê³¼ì •ì…ë‹ˆë‹¤.<br>

### â‘  ì…ë ¥ ë° ìš”ì²­ (Input & Tags)

- í”Œë ˆì´ì–´ê°€ Qí‚¤ ì…ë ¥ â†’ `Input.Action.UsePotion` íƒœê·¸ê°€ ASCë¡œ ì „ë‹¬ë¨.<br>
- ASCëŠ” í•´ë‹¹ íƒœê·¸ì— ë§¤í•‘ëœ `GA_Potion` ì–´ë¹Œë¦¬í‹°ë¥¼ ì°¾ìŒ.<br>

### â‘¡ ì‹¤í–‰ íŒì • (ASC & Tags)

- íƒœê·¸ ê²€ì‚¬: í˜„ì¬ ìºë¦­í„°ì—ê²Œ `State.Debuff.Stun`(ê¸°ì ˆ) íƒœê·¸ê°€ ìˆëŠ”ê°€? (Block Tags í™•ì¸)<br>
- ë¹„ìš© ê²€ì‚¬: ë§ˆë‚˜(Attribute)ê°€ ìˆëŠ”ê°€? ì¿¨íƒ€ì„(Cooldown GE) ì¤‘ì¸ê°€?<br>
- âœ ê²°ê³¼: ëª¨ë‘ í†µê³¼ ì‹œ `ActivateAbility()` í˜¸ì¶œ.<br>

### â‘¢ í–‰ë™ ë° ì‹œê°„ ì§€ì—° (Ability & Task)

- `CommitAbility`: ë§ˆë‚˜ ì°¨ê° ë° ì¿¨íƒ€ì„ GE ì¦‰ì‹œ ì ìš©.<br>
- `Task_PlayMontageAndWait`: í¬ì…˜ ë§ˆì‹œëŠ” ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ ì‹œì‘.<br>
- `(Wait)`: AbilityëŠ” ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚  ë•Œê¹Œì§€ ëŒ€ê¸° ìƒíƒœ ìœ ì§€.<br>

### â‘£ ê²°ê³¼ ì ìš© (Gameplay Effect)

- ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ ì‹œì (OnCompleted)ì— `GE_Heal` ì´í™íŠ¸ë¥¼ ìƒì„±.<br>
- ASCì—ê²Œ `GE_Heal` ì ìš© ìš”ì²­ (SpecHandle ì „ë‹¬).<br>
    - `*GE_Heal` ì •ë³´: Duration=Instant, Modifier=Health Add 50*<br>

### â‘¤ ìƒíƒœ ë³€í™” ë° í”¼ë“œë°± (Attribute & UI)

- `PreAttributeChange`: ì²´ë ¥ì´ MaxHealthë¥¼ ë„˜ì§€ ì•Šë„ë¡ Clamp(ì œí•œ) ì²˜ë¦¬.<br>
- ê°’ ë³€ê²½: `Health` ì†ì„± ê°’ì´ 50 ì¦ê°€.<br>
- ë„¤íŠ¸ì›Œí¬: ì„œë²„ì—ì„œ ë³€ê²½ëœ ê°’ì´ í´ë¼ì´ì–¸íŠ¸ë¡œ ìë™ ë³µì œ(Replication).<br>
- UI ê°±ì‹ : `OnHealthChanged` ë¸ë¦¬ê²Œì´íŠ¸ê°€ í˜¸ì¶œë˜ì–´ HUDì˜ ì²´ë ¥ë°”ê°€ ì¦‰ì‹œ ê°±ì‹ ë¨.<br>

# 2. ìºë¦­í„° ëŒ€ì‹œ ìŠ¤í‚¬ ì˜ˆì œ ì½”ë“œ ğŸ› ï¸

## Step 1. í™˜ê²½ì„¤ì •

### 1-1. í”ŒëŸ¬ê·¸ì¸ í™œì„±í™”

1. ì—ë””í„° ìƒë‹¨ ë©”ë‰´ **Edit** â†’ **Plugins**<br>
2. ê²€ìƒ‰ì°½ì— **Gameplay Abilities** ì…ë ¥<br>
3. **Gameplay Abilities** ì²´í¬ë°•ìŠ¤ í™œì„±í™”<br>
4. **Restart Now** ë²„íŠ¼ í´ë¦­í•˜ì—¬ ì¬ì‹œì‘<br>

### 1-2. Build.cs ì„¤ì •

GAS 3ëŒ€ì¥ ëª¨ë“ˆ (**GameplayAbilities, GameplayTags, GameplayTasks**)ì„ ì¶”ê°€í•©ë‹ˆë‹¤.<br>

```cs
// [ProjectName].Build.cs

using UnrealBuildTool;

public class GASDemo : ModuleRules
{
	public GASDemo(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(new string[] 
        { 
            "Core", 
            "CoreUObject", 
            "Engine", 
            "InputCore", 
            "EnhancedInput",
            // GAS í•„ìˆ˜ ëª¨ë“ˆ 3ëŒ€ì¥ ì¶”ê°€
            "GameplayAbilities", 
            "GameplayTags", 
            "GameplayTasks" 
        });

		PrivateDependencyModuleNames.AddRange(new string[] { });
	}
}
```

## Step 2. ìºë¦­í„° ì„¸íŒ…

- ì´ì œ ìºë¦­í„°ì—ê²Œ ASC (ì‹¬ì¥)ë¥¼ ì´ì‹í•¨.<br>
- ì•„ì§ ìŠ¤íƒ¯ì´ë‚˜ ìŠ¤í‚¬ì€ ì—†ê³ , ì‹œìŠ¤í…œë§Œ íƒ‘ì¬í•˜ëŠ” ë‹¨ê³„<br>

### 1. GASCharacter.h

- `IAbilitySystemInterface`ë¥¼ ìƒì†ë°›ê³ ,<br>
  `GetAbilitySystemComponent()`ë¥¼ ì˜¤ë²„ë¼ì´ë“œí•˜ëŠ” ê²ƒì´ í•µì‹¬<br>

```cpp
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
// ì¸í„°í˜ì´ìŠ¤ì™€ ì»´í¬ë„ŒíŠ¸ í—¤ë” ì¶”ê°€
#include "AbilitySystemInterface.h"
#include "AbilitySystemComponent.h"
#include "GASCharacter.generated.h"

// ì¸í„°í˜ì´ìŠ¤ ìƒì† ì¶”ê°€
UCLASS()
class GASDEMO_API AGASCharacter : public ACharacter, public IAbilitySystemInterface // ì´ê²ƒì„ ìƒì†ë°›ì§€ ì•Šìœ¼ë©´, ì¼ë¶€ ë‚´ë¶€ ì‹œìŠ¤í…œ ì²˜ë¦¬ì— ë¶ˆë¦¬
{
    GENERATED_BODY()

public:
    AGASCharacter();

    // ì¸í„°í˜ì´ìŠ¤ í•„ìˆ˜ êµ¬í˜„ í•¨ìˆ˜
    virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;

protected:
    virtual void BeginPlay() override;

    // ASC ì„ ì–¸
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "GAS")
    TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;
};
```
    
### 2. GASCharacter.cpp

- ASCë¥¼ ìƒì„±í•˜ê³  ì´ˆê¸°í™”í•©ë‹ˆë‹¤.<br>

```cpp
#include "GASCharacter.h"

AGASCharacter::AGASCharacter()
{
    PrimaryActorTick.bCanEverTick = false;
    
    // ASC ìƒì„±
    AbilitySystemComponent = CreateDefaultSubobject<UAbilitySystemComponent>(TEXT("AbilitySystemComponent"));
    // ë©€í‹°í”Œë ˆì´ì–´ ë™ê¸°í™” ì„¤ì •
    AbilitySystemComponent->SetIsReplicated(true);
    AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);
}

UAbilitySystemComponent* AGASCharacter::GetAbilitySystemComponent() const
{
    return AbilitySystemComponent;
}

void AGASCharacter::BeginPlay()
{
    Super::BeginPlay();

    // ASC ì´ˆê¸°í™” (Ownerì™€ Avatar ì„¤ì •)
    if (AbilitySystemComponent)
    {
        // ì´ˆê¸°í™” ì•ˆí•˜ë©´ ASC ë©ˆì¶¤...
        AbilitySystemComponent->InitAbilityActorInfo(this, this);
    }
}
```

- ë©€í‹° í”Œë ˆì´ë¥¼ ìœ„í•´ Replicate ì„¤ì •<br>
  - Player ìºë¦­í„°ë¼ë©´ Mixed ëª¨ë“œ ì¶”ì²œ<br>
    (í´ë¼ì—ì„œ ì´í™íŠ¸ ë“±ì€ ì¬ìƒí•˜ë˜, ê²°ê³¼ë¥¼ ì„œë²„ì™€ ë§ì¶¤)<br>

## Step 3. ìŠ¤íƒ¯ ë§Œë“¤ê¸°

- ASCê°€ ê´€ë¦¬í•  AttributeSetì„ ë§Œë“¤ì–´ ë³´ì. ì²´ë ¥(Health)ì„ ì˜ˆì‹œë¡œ ì‘ì„±<br>

### 1. MyAttributeSet.h

- í¸ë¦¬í•œ ì‚¬ìš©ì„ ìœ„í•´ ë§¤í¬ë¡œë¥¼ ì •ì˜í•˜ê³ , ë³€ìˆ˜(`FGameplayAttributeData`)ë¥¼ ì„ ì–¸<br>

```cpp
#pragma once

#include "CoreMinimal.h"
#include "AttributeSet.h"
#include "AbilitySystemComponent.h" // ë§¤í¬ë¡œ ì‚¬ìš©ì„ ìœ„í•´ í•„ìš”#**include** "MyAttributeSet.generated.h"// â˜… Getter, Setter ìë™ ìƒì„± ë§¤í¬ë¡œ
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
    GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

UCLASS()
class GASDEMO_API UMyAttributeSet : public UAttributeSet
{
    GENERATED_BODY()

public:
    UMyAttributeSet();

    // ë„¤íŠ¸ì›Œí¬ ë³µì œë¥¼ ìœ„í•œ í•¨ìˆ˜ ì˜¤ë²„ë¼ì´ë“œ
    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

    // ì²´ë ¥(Health) ì†ì„± ì •ì˜
    UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = "Vital")
    FGameplayAttributeData Health;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, Health) // ë§¤í¬ë¡œ ì ìš©

    // ìµœëŒ€ ì²´ë ¥(MaxHealth) ì†ì„± ì •ì˜
    UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category = "Vital")
    FGameplayAttributeData MaxHealth;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, MaxHealth)

protected:
    // ê°’ì´ ë³€ê²½ë  ë•Œ í´ë¼ì´ì–¸íŠ¸ì—ì„œ í˜¸ì¶œë  í•¨ìˆ˜
    UFUNCTION()
    void OnRep_Health(const FGameplayAttributeData& OldValue);

    UFUNCTION()
    void OnRep_MaxHealth(const FGameplayAttributeData& OldValue);
};
```

- í•˜ë‚˜ì˜ ìŠ¤íƒ¯ ê°œë…ì„ ìœ„í•˜ì—¬<br>
  í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì•¼ í•´ì¤Œ<br> 

### 2. MyAttributeSet.cpp

- ìƒì„±ìì—ì„œ ì´ˆê¸°ê°’ì„ ì¡ê³ , ë¦¬í”Œë¦¬ì¼€ì´ì…˜(ë™ê¸°í™”) ë¡œì§ì„ ì—°ê²°

```cpp
#include "MyAttributeSet.h"
#include "Net/UnrealNetwork.h" // DOREPLIFETIME ë§¤í¬ë¡œìš©

UMyAttributeSet::UMyAttributeSet()
{
    // ê¸°ë³¸ê°’ ì´ˆê¸°í™” (ë§¤í¬ë¡œë¡œ ìƒì„±ëœ í•¨ìˆ˜ë“¤)
    InitHealth(100.0f);
    InitMaxHealth(100.0f);
}

void UMyAttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    // ë„¤íŠ¸ì›Œí¬ ë™ê¸°í™” ë“±ë¡
    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Health, COND_None, REPNOTIFY_Always);
    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always);
}

void UMyAttributeSet::OnRep_Health(const FGameplayAttributeData& OldValue)
{
    // GAS ì‹œìŠ¤í…œì— ê°’ ë³€ê²½ ì•Œë¦¼ (ë„¤íŠ¸ì›Œí¬!)
    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Health, OldValue);
}

void UMyAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldValue)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, MaxHealth, OldValue);
}
```

- GASì—ì„  ì˜ˆì¸¡ ì‹œìŠ¤í…œì´ ì¡´ì¬í•˜ê¸°ì—<br>
  DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Health, COND_None, REPNOTIFY_Always);<br>
  ì´ ë°©ì‹ì„ ì‚¬ìš©í•¨<br>

### 3. ìºë¦­í„° (GASCharacter) ì—…ë°ì´íŠ¸

- ì´ì œ ë§Œë“  AttributeSetì„ ìºë¦­í„°ì— ë¶™ì—¬ì¤Œ.<br>

```cpp
// GASCharacter.h (ì¶”ê°€)
class UMyAttributeSet; // ì „ë°© ì„ ì–¸

// ... ê¸°ì¡´ ì½”ë“œ ...
protected:
    // AttributeSet í¬ì¸í„° ì¶”ê°€
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "GAS")
    TObjectPtr<UMyAttributeSet> AttributeSet;
```

```cpp
// GASCharacter.cpp (ì¶”ê°€)
#include "MyAttributeSet.h" // í—¤ë” í¬í•¨

AGASCharacter::AGASCharacter()
{
    // ... ASC ìƒì„± ì½”ë“œ ...
    
    // AttributeSet ìƒì„±
    AttributeSet = CreateDefaultSubobject<UMyAttributeSet>(TEXT("AttributeSet"));
}
```

- AttributeSetì„ ê°€ì§ìœ¼ë¡œì„œ ê·¸ ë‚´ë¶€ ìŠ¤íƒ¯ë“¤ì„ ê´€ë¦¬í•˜ëŠ” Setì„ ê°€ì§€ê²Œ ë¨<br>

## Step 4. ëŒ€ì‹œ ìŠ¤í‚¬ êµ¬í˜„

- ë§ˆì§€ë§‰ìœ¼ë¡œ, ì…ë ¥(Space Bar)ì„ ë°›ìœ¼ë©´ ì•ìœ¼ë¡œ íŠ€ì–´ ë‚˜ê°€ëŠ” **Dash Ability**ë¥¼ ë§Œë“¤ê³  ì—°ê²°í•¨.<br>

### 1. DashAbility.h

- GASì˜ `UGameplayAbility`ë¥¼ ìƒì†ë°›ì•„ ëŒ€ì‹œ ë¡œì§ì„ ì •ì˜í•¨.<br>

```cpp
// DashAbility.h
#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "DashAbility.generated.h"

UCLASS()
class GASDEMO_API UDashAbility : public UGameplayAbility
{
    GENERATED_BODY()

public:
    UDashAbility();

protected:
    // ì–´ë¹Œë¦¬í‹° ì‹¤í–‰ ë¡œì§ (Activate)
    virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

    // ì–´ë¹Œë¦¬í‹° ì¢…ë£Œ ë¡œì§ (End)
    virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;

    // Task ì™„ë£Œ ì½œë°± í•¨ìˆ˜
    UFUNCTION()
    void OnDashFinished();

protected:
    UPROPERTY(EditDefaultsOnly, Category = "Dash")
    float DashDistance = 1000.0f;

    UPROPERTY(EditDefaultsOnly, Category = "Dash")
    float DashDuration = 0.2f;
};
```


### 2. DashAbility.cpp

- `Activate` -> `Commit` -> `RootMotion` -> `End`ë¡œ ì´ì–´ì§€ëŠ” íë¦„ì„ êµ¬í˜„í•˜ê¸°<br>

```cpp
// DashAbility.cpp
#include "DashAbility.h"
#include "GameFramework/Character.h"
#include "Abilities/Tasks/AbilityTask_ApplyRootMotionConstantForce.h"
#include "Abilities/Tasks/AbilityTask_WaitDelay.h"

UDashAbility::UDashAbility()
{
    // ì¤‘ìš”: ìºë¦­í„°ë§ˆë‹¤ ë³„ë„ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (ë³€ìˆ˜ ì €ì¥ ìœ„í•¨)
    // ì•¡í„°ë³„ í• ë‹¹
    InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
}

void UDashAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
    // 1. ì¿¨íƒ€ì„/ë¹„ìš© í™•ì¸ ë° ì ìš© (Commit) - ì¡°ê±´ í™•ì¸
    if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
    {
        EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
        return;
    }

    // 2. ìºë¦­í„° ë°©í–¥ ê³„ì‚°
    ACharacter* Character = CastChecked<ACharacter>(ActorInfo->AvatarActor);
    FVector DashDir = Character->GetActorForwardVector();

    // 3. ë£¨íŠ¸ ëª¨ì…˜ íƒœìŠ¤í¬ ì‹¤í–‰ (í˜ ì ìš©) - ìºë¦­í„°ë¥¼ ë°€ì–´ì£¼ëŠ” ì—”ì§„
    // (Launch ì•ˆì“°ëŠ” ì´ìœ ëŠ” ì´ í•¨ìˆ˜ê°€ ë©€í‹°í”Œë ˆì´ ë™ê¸°í™”ë¥¼ í•´ì£¼ê¸°ì—)
    UAbilityTask_ApplyRootMotionConstantForce* RootMotionTask = UAbilityTask_ApplyRootMotionConstantForce::ApplyRootMotionConstantForce(
        this, 
        FName("Dash"), 
        DashDir, 
        DashDistance / DashDuration, // ì†ë„ = ê±°ë¦¬ / ì‹œê°„
        DashDuration, 
        false, nullptr, 
        ERootMotionFinishVelocityMode::MaintainLastRootMotionVelocity, 
        FVector::ZeroVector, 
        0.f, true
    );
    
    if (RootMotionTask)
    {
        RootMotionTask->ReadyForActivation();
    }

    // 4. ëŒ€ê¸° íƒœìŠ¤í¬ ì‹¤í–‰ (ì‹œê°„ ê²½ê³¼ í›„ ì¢…ë£Œ)
    UAbilityTask_WaitDelay* DelayTask = UAbilityTask_WaitDelay::WaitDelay(this, DashDuration);
    if (DelayTask)
    {
        DelayTask->OnFinish.AddDynamic(this, &UDashAbility::OnDashFinished);
        DelayTask->ReadyForActivation();
    }
}

void UDashAbility::OnDashFinished()
{
    // 5. ì •ìƒ ì¢…ë£Œ
    EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);
}

void UDashAbility::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
    Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
    // (ë£¨íŠ¸ ëª¨ì…˜ íƒœìŠ¤í¬ëŠ” Ability ì¢…ë£Œ ì‹œ ìë™ìœ¼ë¡œ ì •ë¦¬ë¨)
}
```


### 3. ìºë¦­í„°(GASCharacter) ìµœì¢… ì—…ë°ì´íŠ¸: ì…ë ¥ ë°”ì¸ë”©

- ì´ì œ ìŠ¤í‚¬ì„ ìºë¦­í„°ì— ë“±ë¡(`GiveAbility`)í•˜ê³ , ì…ë ¥ê³¼ ì—°ê²°<br>

```cpp
// GASCharacter.h (ìµœì¢…)
class UInputAction; // ì „ë°© ì„ ì–¸

// ... ê¸°ì¡´ ì½”ë“œ ...

protected:
    // ì‹œì‘ ì‹œ ë¶€ì—¬í•  ì–´ë¹Œë¦¬í‹° ëª©ë¡
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GAS")
    TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;
    
    // ëŒ€ì‹œ ì…ë ¥ ì•¡ì…˜ (IA_Dash)
    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
    TObjectPtr<UInputAction> IA_Dash;

    // ì…ë ¥ ì²˜ë¦¬ í•¨ìˆ˜
    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
    void HandleDashInput();
```

```cpp
// GASCharacter.cpp (ìµœì¢…)
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"

void AGASCharacter::BeginPlay()
{
    Super::BeginPlay();

    if (AbilitySystemComponent)
    {
        AbilitySystemComponent->InitAbilityActorInfo(this, this);

        // ì„œë²„ ê¶Œí•œ(Authority)ì´ ìˆì„ ë•Œë§Œ ìŠ¤í‚¬ ë¶€ì—¬!
        if (HasAuthority())
        {
            for (TSubclassOf<UGameplayAbility> AbilityClass : StartupAbilities)
            {
                AbilitySystemComponent->GiveAbility(FGameplayAbilitySpec(AbilityClass, 1));
            }
        }
    }
}

void AGASCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    Super::SetupPlayerInputComponent(PlayerInputComponent);

    // Enhanced Input ë°”ì¸ë”©
    if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))
    {
        EnhancedInputComponent->BindAction(IA_Dash, ETriggerEvent::Started, this, &AGASCharacter::HandleDashInput);
    }
}

void AGASCharacter::HandleDashInput()
{
    // Tagë¥¼ ì‚¬ìš©í•˜ì—¬ Ability ì‹¤í–‰ ìš”ì²­
    // (StartupAbilitiesì— DashAbilityê°€ ë“±ë¡ë˜ì–´ ìˆì–´ì•¼ í•¨)
    FGameplayTagContainer TagContainer;
    TagContainer.AddTag(FGameplayTag::RequestGameplayTag(FName("Ability.Action.Dash"))); // íƒœê·¸ëŠ” ì˜ˆì‹œë¡œ ë„£ì€ê²ƒ
}
```
    
## Step 5. ì—ë””í„° ì„¸íŒ…ê³¼ í…ŒìŠ¤íŠ¸

1. **ë¸”ë£¨í”„ë¦°íŠ¸ ìƒì„± (ìƒì†)**<br>
    - C++ `AGASCharacter`ë¥¼ ìƒì†ë°›ëŠ” `BP_GASCharacter`ë¥¼ ìƒì„±<br>
    - C++ `UDashAbility`ë¥¼ ìƒì†ë°›ëŠ” `GA_Dash`ë¥¼ ìƒì„±<br>
2. **ë°ì´í„° ì—°ê²° (Configuration)**<br>
    - `GA_Dash` íŒŒì¼ì„ ì—´ì–´ì„œ `Dash Distance`ë¥¼ 1000ìœ¼ë¡œ, `Dash Duration`ì„ 0.2ë¡œ ì„¤ì • (ê¸°íšìì˜ ì˜ì—­)<br>
    - `BP_GASCharacter`ë¥¼ ì—´ì–´ì„œ `Startup Abilities` ëª©ë¡ì— `GA_Dash`ë¥¼ ë“±ë¡<br>
3. **ì…ë ¥ ì‹œìŠ¤í…œ ì„¤ì • (Enhanced Input)**<br>
    - **Input Action (`IA_Dash`)** ì—ì…‹ì„ ìƒì„±<br>
    - Input Mapping Context (`IMC_Default`)ë¥¼ ë§Œë“¤ê³  ì›í•˜ëŠ” í‚¤ë¥¼ ì—°ê²°<br>
    - ì´ê±¸ ìºë¦­í„° ë¸”ë£¨í”„ë¦°íŠ¸ì˜ ìŠ¬ë¡¯ì— ë¼ì›Œ ë„£ê¸°<br>
4. **Play In Editor (PIE)**<br>
    - ê²Œì„ì„ ì‹¤í–‰í•˜ê³  ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆŒëŸ¬ ìºë¦­í„°ê°€ ì‹¤ì œë¡œ íŠ€ì–´ë‚˜ê°€ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.<br>
5. **`ShowDebug AbilitySystem` (GASì˜ ì‹ ì˜ ëª…ë ¹ì–´)**<br>
    - ì½˜ì†”(`~` í‚¤)ì„ ì—´ê³  ì´ ëª…ë ¹ì–´ë¥¼ ì³ë³´ì!<br>
    - ê·¸ëŸ¬ë©´ í™”ë©´ ì˜†ì— ASCì˜ ë‚´ë¶€ ìƒíƒœ(í˜„ì¬ ì²´ë ¥, ì ìš©ëœ íƒœê·¸, ì‹¤í–‰ ì¤‘ì¸ ìŠ¤í‚¬)ê°€ ì‹¤ì‹œê°„ í…ìŠ¤íŠ¸ë¡œ ëœ¸.<br>
    - *"ëŒ€ì‹œë¥¼ ì“¸ ë•Œ `Ability.Action.Dash` íƒœê·¸ê°€ ì¼œì¡Œë‹¤ê°€ êº¼ì§€ëŠ”ê°€?"* ë¥¼ ëˆˆìœ¼ë¡œ í™•ì¸<br>

# 3. ì „ì²´ ì™„ì„± ì½”ë“œ ğŸ˜¶â€ğŸŒ«ï¸

### Build.cs ì„¤ì •

```cs
using UnrealBuildTool;

public class GASDemo : ModuleRules
{
	public GASDemo(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(new string[] 
		{ 
			"Core", 
			"CoreUObject", 
			"Engine", 
			"InputCore", 
			"EnhancedInput",
			// â˜… GAS í•„ìˆ˜ 3ëŒ€ì¥ ëª¨ë“ˆ í™•ì¸
			"GameplayAbilities", 
			"GameplayTags", 
			"GameplayTasks" 
		});

		PrivateDependencyModuleNames.AddRange(new string[] { });
	}
}
```

- **GameplayAbilities**: ASCì™€ Abilityì˜ í•µì‹¬<br>
- **GameplayTags**: Effectë¥¼ êµ¬ë¶„í•˜ê³  ê´€ë¦¬í•˜ëŠ” ë¼ë²¨ ì‹œìŠ¤í…œ<br>
- **GameplayTasks**: Abilityê°€ ì‹œê°„ì´ ê±¸ë¦¬ëŠ” ì‘ì—…ì„ í•  ë•Œ í•„ìš”<br>

## 1. GASCharacter.h

```cpp
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "AbilitySystemInterface.h" // í•„ìˆ˜ ì¸í„°í˜ì´ìŠ¤
#include "AbilitySystemComponent.h"
#include "GASCharacter.generated.h"

class UMyAttributeSet;
class UInputAction;
class UInputMappingContext;
class UGameplayAbility;

UCLASS()
class GASDEMO_API AGASCharacter : public ACharacter, public IAbilitySystemInterface
{
	GENERATED_BODY()

public:
	AGASCharacter();

	// â˜… IAbilitySystemInterface êµ¬í˜„ (Getter)
	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;

protected:
	virtual void BeginPlay() override;
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

public:
	// ASC ì»´í¬ë„ŒíŠ¸
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "GAS")
	TObjectPtr<UAbilitySystemComponent> AbilitySystemComponent;

	// AttributeSet
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "GAS")
	TObjectPtr<UMyAttributeSet> AttributeSet;

protected:
	// ì‹œì‘ ì‹œ ë¶€ì—¬í•  ìŠ¤í‚¬ ëª©ë¡
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GAS")
	TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;

	// ëŒ€ì‹œ ìŠ¤í‚¬ (í´ë˜ìŠ¤ ì •ë³´)
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GAS")
	TSubclassOf<UGameplayAbility> DashAbilityClass;

	// --- Enhanced Input ---
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	TObjectPtr<UInputMappingContext> DefaultMappingContext;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	TObjectPtr<UInputAction> IA_Move;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	TObjectPtr<UInputAction> IA_Look;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input")
	TObjectPtr<UInputAction> IA_Dash;

	// ì…ë ¥ í•¨ìˆ˜
	void Move(const struct FInputActionValue& Value);
	void Look(const struct FInputActionValue& Value);
	void Dash(const struct FInputActionValue& Value);
};
```

## 2. GASCharacter.cpp

```cpp
#include "GASCharacter.h"
#include "MyAttributeSet.h"
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"
#include "GameFramework/CharacterMovementComponent.h"

AGASCharacter::AGASCharacter()
{
	PrimaryActorTick.bCanEverTick = false;
	bReplicates = true;

	// 1. ASC ìƒì„± (Mixed ëª¨ë“œëŠ” ë©€í‹°í”Œë ˆì´ì–´ PlayerStateìš© í‘œì¤€)
	AbilitySystemComponent = CreateDefaultSubobject<UAbilitySystemComponent>(TEXT("AbilitySystemComponent"));
	AbilitySystemComponent->SetIsReplicated(true);
	AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);

	// 2. AttributeSet ìƒì„±
	AttributeSet = CreateDefaultSubobject<UMyAttributeSet>(TEXT("AttributeSet"));
}

UAbilitySystemComponent* AGASCharacter::GetAbilitySystemComponent() const
{
	return AbilitySystemComponent;
}

void AGASCharacter::BeginPlay()
{
	Super::BeginPlay();

	// 3. ASC ì´ˆê¸°í™” (OwnerActor = Self, AvatarActor = Self)
	if (AbilitySystemComponent)
	{
		AbilitySystemComponent->InitAbilityActorInfo(this, this);

		// ìŠ¤í‚¬ ë¶€ì—¬ëŠ” ë°˜ë“œì‹œ ì„œë²„(Authority)ì—ì„œë§Œ ì‹¤í–‰!
		if (HasAuthority())
		{
			for (TSubclassOf<UGameplayAbility> AbilityClass : StartupAbilities)
			{
				if (AbilityClass)
				{
					AbilitySystemComponent->GiveAbility(FGameplayAbilitySpec(AbilityClass, 1));
				}
			}
		}
	}
}

void AGASCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	// 4. ì…ë ¥ ë§¤í•‘ ë° ë°”ì¸ë”© (ì´ê³³ì´ ê°€ì¥ ì•ˆì „í•œ ìœ„ì¹˜ì…ë‹ˆë‹¤)
	if (APlayerController* PlayerController = Cast<APlayerController>(Controller))
	{
		if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))
		{
			Subsystem->AddMappingContext(DefaultMappingContext, 0);
		}
	}

	if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))
	{
		EnhancedInputComponent->BindAction(IA_Move, ETriggerEvent::Triggered, this, &AGASCharacter::Move);
		EnhancedInputComponent->BindAction(IA_Look, ETriggerEvent::Triggered, this, &AGASCharacter::Look);
		EnhancedInputComponent->BindAction(IA_Dash, ETriggerEvent::Started, this, &AGASCharacter::Dash);
	}
}

void AGASCharacter::Move(const FInputActionValue& Value)
{
	FVector2D MovementVector = Value.Get<FVector2D>();
	if (Controller != nullptr)
	{
		const FRotator Rotation = Controller->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);
		const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
		const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);

		AddMovementInput(ForwardDirection, MovementVector.Y);
		AddMovementInput(RightDirection, MovementVector.X);
	}
}

void AGASCharacter::Look(const FInputActionValue& Value)
{
	FVector2D LookAxisVector = Value.Get<FVector2D>();
	if (Controller != nullptr)
	{
		AddControllerYawInput(LookAxisVector.X);
		AddControllerPitchInput(LookAxisVector.Y);
	}
}

void AGASCharacter::Dash(const FInputActionValue& Value)
{
	// 5. ASCë¥¼ í†µí•´ ëŒ€ì‹œ ìŠ¤í‚¬ ë°œë™ ìš”ì²­
	// (ì‹¤ë¬´ì—ì„  íƒœê·¸ë¡œ í•˜ì§€ë§Œ, ì…ë¬¸ ê°•ì˜ì—ì„  Class ê¸°ë°˜ ì‹¤í–‰ì´ ê°€ì¥ ì§ê´€ì ì„)
	if (AbilitySystemComponent && DashAbilityClass)
	{
		AbilitySystemComponent->TryActivateAbilityByClass(DashAbilityClass);
	}
}
```

## 3. MyAttributeSet.h

```cpp
#pragma once

#include "CoreMinimal.h"
#include "AttributeSet.h"
#include "AbilitySystemComponent.h"
#include "MyAttributeSet.generated.h"

// í¸ì˜ì„± ë§¤í¬ë¡œ (ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ ì œê±°ìš©)
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

UCLASS()
class GASDEMO_API UMyAttributeSet : public UAttributeSet
{
	GENERATED_BODY()

public:
	UMyAttributeSet();
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

	// Health
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = "Vital")
	FGameplayAttributeData Health;
	ATTRIBUTE_ACCESSORS(UMyAttributeSet, Health)

	// MaxHealth
	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category = "Vital")
	FGameplayAttributeData MaxHealth;
	ATTRIBUTE_ACCESSORS(UMyAttributeSet, MaxHealth)

protected:
	UFUNCTION()
	void OnRep_Health(const FGameplayAttributeData& OldValue);

	UFUNCTION()
	void OnRep_MaxHealth(const FGameplayAttributeData& OldValue);

	// ê°’ ë³€ê²½ ì „ ë³´ì •(Clamping)
	virtual void PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue) override;
};
```

## 4. MyAttributeSet.cpp

```cpp
#include "MyAttributeSet.h"
#include "Net/UnrealNetwork.h"

UMyAttributeSet::UMyAttributeSet()
{
	InitHealth(100.0f);
	InitMaxHealth(100.0f);
}

void UMyAttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	// REPNOTIFY_Always: ê°’ì´ ë¡¤ë°±ë˜ì–´ë„ UI ê°±ì‹ ì„ ë³´ì¥í•¨
	DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Health, COND_None, REPNOTIFY_Always);
	DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always);
}

void UMyAttributeSet::OnRep_Health(const FGameplayAttributeData& OldValue)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Health, OldValue);
}

void UMyAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldValue)
{
	GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, MaxHealth, OldValue);
}

void UMyAttributeSet::PreAttributeChange(const FGameplayAttribute& Attribute, float& NewValue)
{
	Super::PreAttributeChange(Attribute, NewValue);

	// ì²´ë ¥ì´ 0 ~ MaxHealth ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ ê°•ì œ (Clamping)
	if (Attribute == GetHealthAttribute())
	{
		NewValue = FMath::Clamp(NewValue, 0.0f, GetMaxHealth());
	}
}
```

## 5. DashAbility.h

```cpp
#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"
#include "DashAbility.generated.h"

UCLASS()
class GASDEMO_API UDashAbility : public UGameplayAbility
{
	GENERATED_BODY()

public:
	UDashAbility();

protected:
	// ì–´ë¹Œë¦¬í‹° í™œì„±í™” (ì‹¤í–‰)
	virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override;

	// ì–´ë¹Œë¦¬í‹° ì¢…ë£Œ
	virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override;

	// íƒœìŠ¤í¬ ì™„ë£Œ ì½œë°±
	UFUNCTION()
	void OnDashFinished();

protected:
	UPROPERTY(EditDefaultsOnly, Category = "Dash")
	float DashDistance = 1000.0f;

	UPROPERTY(EditDefaultsOnly, Category = "Dash")
	float DashDuration = 0.2f;
};
```

## 6. DashAbility.cpp

```cpp
#include "DashAbility.h"
#include "GameFramework/Character.h"
#include "Abilities/Tasks/AbilityTask_ApplyRootMotionConstantForce.h"
#include "Abilities/Tasks/AbilityTask_WaitDelay.h"

UDashAbility::UDashAbility()
{
	// ìºë¦­í„°ë§ˆë‹¤ ê°œë³„ ìƒíƒœ ì €ì¥ì„ ìœ„í•´ Instancing í•„ìˆ˜
	InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
}

void UDashAbility::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)
{
	// 1. ì»¤ë°‹ (ì¿¨íƒ€ì„, ë¹„ìš© í™•ì¸)
	if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
	{
		EndAbility(Handle, ActorInfo, ActivationInfo, true, true);
		return;
	}

	ACharacter* Character = CastChecked<ACharacter>(ActorInfo->AvatarActor);
	FVector DashDir = Character->GetActorForwardVector();

	// 2. ë£¨íŠ¸ ëª¨ì…˜ íƒœìŠ¤í¬ (ìºë¦­í„° ì´ë™ í˜ ì ìš©)
	UAbilityTask_ApplyRootMotionConstantForce* RootMotionTask = UAbilityTask_ApplyRootMotionConstantForce::ApplyRootMotionConstantForce(
		this,
		FName("Dash"),
		DashDir,
		DashDistance / DashDuration,
		DashDuration,
		false, nullptr,
		ERootMotionFinishVelocityMode::MaintainLastRootMotionVelocity,
		FVector::ZeroVector,
		0.f, true
	);

	if (RootMotionTask)
	{
		RootMotionTask->ReadyForActivation();
	}

	// 3. ë”œë ˆì´ íƒœìŠ¤í¬ (ëŒ€ì‹œ ì§€ì†ì‹œê°„ë§Œí¼ ëŒ€ê¸°)
	UAbilityTask_WaitDelay* DelayTask = UAbilityTask_WaitDelay::WaitDelay(this, DashDuration);
	if (DelayTask)
	{
		DelayTask->OnFinish.AddDynamic(this, &UDashAbility::OnDashFinished);
		DelayTask->ReadyForActivation();
	}
}

void UDashAbility::OnDashFinished()
{
	// 4. ì¢…ë£Œ ì²˜ë¦¬
	EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);
}

void UDashAbility::EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled)
{
	Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}
```