---
title: "서버에 대하여"
date : "2025-11-18 13:00:00 +0900"
last_modified_at: "2025-11-18T13:00:00"
categories:
  - Unreal
  - C++
tags:
  - Unreal
  - C++
  - Server
---

## 게임 서버에 대하여

일반적인 온라인 게임이라면<br>
게임 서버 외에도 다양한 서버가 존재한다<br>

- 게임 서버 (우리가 다룰 내용)<br>
- 로그인 서버<br>
- 계정 관리용 서버<br>
- 로비 Or 채팅용 서버<br>
- DB 서버<br>
- 결제용 서버 등 그 외의 서버들<br>

이건 '게임의 구조' 보다는<br>
'전반적인 프로그램/게임 서비스 의 구조'에 가깝기도 하여<br>
너무 깊게 다루지는 않을 예정이다<br>

## 게임 서버의 종류

게임 서버는 크게 3가지 종류로 나뉜다<br>

- P2P(다만 이 구조는 네트워크 모델에 가까운 개념)<br>
- Listen Server<br>
- Dedicated Server<br>

### 사전 요약 표

| 모델                    | 서버 존재 | 누가 서버 역할? | 해킹·보안 | 대규모 가능? | 사용처        |
| --------------------- | ----- | --------- | ----- | ------- | ---------- |
| **P2P**               | 없음    | 모두        | 최악    | 불가      | 구시대 RTS    |
| **Listen Server**     | 있음    | 플레이어 한 명  | 낮음    | 낮음      | 소규모 협동     |
| **Dedicated Server**  | 있음    | 독립된 서버    | 매우 높음 | 최고      | 대부분의 AAA   |

## P2P (Peer-to-Peer)
[![Image](https://github.com/user-attachments/assets/f6b16434-db1d-426c-b5ee-13a0d354370f)](https://github.com/user-attachments/assets/f6b16434-db1d-426c-b5ee-13a0d354370f){: .image-popup}<br>

```lua
 A  <---->  B
 |  \      / |
 |    \  /   |
 \      X    /
   \    |   /
       C
```

**모든 플레이어가 서로 직접 통신하는 구조**<br>

사실 별도의 '서버'를 사용하기 보다는<br>
각각의 플레이어(클라이언트)가 서로에게 직접 패킷을 주고 받음<br>

플레이어 A의 입력이 B,C 등을 전달되고<br>
B의 입력 또한 A,C 등으로 전달되는 방식<br>

- 어찌보면 모두가 서버 역할을 한다 볼 수 있음<br>
- 그렇기에 권한(Auth)을 가진 서버가 없음<br>

- 사용된 게임들?<br>
  : 스타1, 워크3, 철권 6, 콘솔/아케이드 계열의 온라인 게임<br>

공평한 처리를 위하여<br>
`LockStep` 방식을 채용<br>

- 모든 플레이어가 다음 프레임 계산 전에<br>
  '서로'의 모든 정보를 받아야 함<br>

- 100% 동기화되지만,<br>
  한 명의 사양이 느릴경우, 전체가 느려지는 단점이 있었음<br>
  (과거의 게임에서 사양 안좋은 1명 참가시, 전체 게임이 느려진 사유)<br>

### 장점/단점

- 장점<br>
  - 모든 플레이어가 동등한 '권한'을 지녀 구조적으로 단순<br>
  - 모든 플레이어의 사양이 동일하고 근접한 위치라면 지연이 거의 없음<br>
  - 서버 유지 비용 x<br>

- 단점<br>
  - 보안이 사실상 없음(모든 플레이어가 '동등'한 권한이 있으므로)<br>
  - 사양이 안좋은 쪽에 맞춰짐<br>
  - 인원이 늘어날수록 성능적인 문제 또한 심각해짐<br>

### 여전히 사용하는가?

거의 사용하지 않지만<br>
특정 장르에서 '응용'하여 사용됨<br>

- 격투게임에서<br>
  게임 플레이의 지연을 줄이기 위해 사용<br>
  (1 ㄷ 1은 Peer to Peer에 적합함)<br>
  - 다만 보안 문제를 위하여 'Rollback NetCode'라는<br>
    안전하게 응용한 방식을 채택한 것<br>
    (격투 게임은 입력 지연을 최소화하는 것이 UX에 직결되므로)<br>
  - 또한 격투게임은 '입력 정보'만을 교환하기에 비교적 안전한 편<br>

- 그 외에도 1대 1 경쟁 같은 모바일 계열에서 채택 가능<br>

클라이언트의 입력 값이 '단순'하고<br>
그에 따라 양측에서 데이터 변조 가능성이 적다면<br>
채택을 고심할만 하다<br>

## Listen Server

[![Image](https://github.com/user-attachments/assets/bd61518c-a6b5-422e-9418-36ad5a4d0747)](https://github.com/user-attachments/assets/bd61518c-a6b5-422e-9418-36ad5a4d0747){: .image-popup}<br>

**플레이어 중 한 명이 '서버' 역할을 동시에 맞는 구조**<br>

- Host : Server + Client<br>
- 나머지 : 일반 Client<br>

Host는 같은 프로세스 내부에서<br>
서버 로직 - 게임 로직, Actor 관리 및 판정<br>
클라 로직 - 렌더링 , UI<br>
가 동시에 돌아감<br>

다른 Guest 들은 Host_IP를 통해 계산받음<br>

어찌본다면 권한을 Host에 몰아준<br>
P2P의 일종에 가깝기도 하다<br>
(권한 모델 자체는 Dedicated 와 비슷한 편)<br>

다만, Host의 게임 종료 시,<br>
모든 플레이어가 같이 종료됨<br>

- 사용된 게임?<br>
  : 마인크래프트, 어몽어스, 테라리아 등 소규모 협동 게임 계열<br>

- Unreal에서도 설정을 통해 구현이 가능<br>

### 장점 / 단점

- 장점<br>
  - 서버 유지비 필요 x (역시 클라이언트 중 하나가 서버 역할을 하므로)<br>
  - 설정이 다소 쉬운 편<br>

- 단점<br>
  - Host의 성능이 곧 서버의 성능에 직결됨<br>
  - Host 종료 시, 게임 종료<br>
  - 보안 이슈 (Host의 데이터 조작 가능성은 남아 있음)<br>

### 어떤 게임에 사용하는가?

- 소규모 협동 게임<br>
- 파티 게임<br>
- 서바이벌 / 생존 / 건설 계열<br>
- 싱글 게임이지만 멀티 지원<br>

보안적 이슈로 인하여, 경쟁 계열 게임에서는 채택하진 않는 편<br>

## Dedicated Server

[![Image](https://github.com/user-attachments/assets/735a2e47-13da-4e52-abf7-db0e1edeb98a)](https://github.com/user-attachments/assets/735a2e47-13da-4e52-abf7-db0e1edeb98a){: .image-popup}<br>

**플레이어가 아닌, 서버용 프로그램만을 실행하는 구조**<br>

- 서버 역할의 프로그램이 별도로 존재<br>
  - 서버는 렌더링 X(그래픽 X)<br>
  - 사운드, UI, 입력 등도 없음<br>
  - 오로지 게임 로직을 처리해주는 역할만 수행<br>

- 대부분의 게임 로직을 수행<br>
  - Actor 생성 및 파괴<br>
  - 물리/충돌<br>
  - AI의 로직<br>
  - 움직임 관리<br>
  - GameState, GameMode 관리<br>
  -> 클라이언트는 '렌더링/UI/Input'처리만 진행하도록!<br>

대부분의 '경쟁' 게임에서 사용하는 게임 서버 구조<br>

### 실행 흐름

1. 서버 프로세스 실행<br>

- PIE, Server.exe 를 통해 실행한 방식<br>
  (실행할 때 Open {Level이름}?Listen 명령어가 인자로 전달)<br>
  (해당 Level을 열어둠)<br>

- Socket을 생성하고 다른 PC가 접속 가능하게 함<br>

[![Image](https://github.com/user-attachments/assets/f9301f47-5e4d-41f3-8332-ae2a5defd66b)](https://github.com/user-attachments/assets/f9301f47-5e4d-41f3-8332-ae2a5defd66b){: .image-popup}<br>

2. 서버가 게임 World 생성<br>

- Level의 WorldSettings를 통해<br>
  GameMode, GameState 액터를 생성<br>

- GameMode는 서버에만 존재<br>

[![Image](https://github.com/user-attachments/assets/e3f28390-7295-4706-bc37-e9bd3cb28158)](https://github.com/user-attachments/assets/e3f28390-7295-4706-bc37-e9bd3cb28158){: .image-popup}<br>

3. 클라이언트의 접속 시도<br>

- 클라이언트는 서버의 IP와 Port 번호로 접속을 시도<br>
- 서버는 접속 시도하는 클라이언트에 Level 정보를 넘김<br>
- 클라이언트가 Level Open 성공시, 다시 서버로 결과 송신<br>

[![Image](https://github.com/user-attachments/assets/80569454-8c4d-4bce-89d1-2e62abf6f895)](https://github.com/user-attachments/assets/80569454-8c4d-4bce-89d1-2e62abf6f895){: .image-popup}<br>


4. 접속 성공한 클라이언트용 데이터를 생성 후 복제

- 서버에서 PlayerState, PlayerController, PlayerCharacter 생성<br>
- 이후, 접속한 클라이언트에 복제<br>
  (이 때 GameState도 복제하여 전송)<br>

[![Image](https://github.com/user-attachments/assets/a35da0ae-de75-46bc-8e38-d9fd0f778113)](https://github.com/user-attachments/assets/a35da0ae-de75-46bc-8e38-d9fd0f778113){: .image-popup}<br>

5. 접속 시도 2<br>

- 마찬가지로 클라 2도 접속 요청<br>

[![Image](https://github.com/user-attachments/assets/5005c7a1-a18c-4cd8-a76a-0f5dcfc9ac15)](https://github.com/user-attachments/assets/5005c7a1-a18c-4cd8-a76a-0f5dcfc9ac15){: .image-popup}<br>

6. 복제 2<br>

- 이 때, 신규 접속한 클라2의 데이터 중<br>
  PlayerState, PlayerCharacter를 클라1에도 복제하여 전송함<br>

- 마찬가지로 클라2에도 클라1의 PlayerState, PlayerCharacter가 복제되어 전송됨<br>

[![Image](https://github.com/user-attachments/assets/d3c0646b-8eb6-479e-a8f3-15be539562c4)](https://github.com/user-attachments/assets/d3c0646b-8eb6-479e-a8f3-15be539562c4){: .image-popup}<br>


- 클라이언트 <-> 클라이언트의 직접 통신은 x<br>

- 진짜 핵심적인 로직은 서버에서 '진짜'를 관리<br>
  - 필요한 데이터만을 클라이언트로 '복사'하여 전달함<br>
  - RPC, Replicate 프로퍼티와 연관된 핵심 개념중 하나<br> 
    - RPC(Remote Procedure Call) : 서버->클라, 클라-> 서버 등 특정 호출로 인한 이벤트 처리<br>
    - Replicate Property : 서버->클라 를 통해 변수 와 같은 데이터 동기화 처리<br>
      (이 둘은 나중에 더 자세히 알아볼 예정)<br>

### 장점 / 단점

- 장점<br>
  - 높은 보안성, 그로 인한 공정성<br>
  - 확장성으로 인한 대규모 인원 접속 가능<br>
  - 각 PC 성능과 게임 로직과 무관<br>
  - 서버의 유지/ 종료 를 서버 회사가 통제<br>

- 단점<br>
  - 운영 비용 발생(일반적으로 AWS 등을 사용하여 서버 비용 부담)<br>
  - 배포 프로그램의 복잡성 (업데이트/패치 에 대한 처리 필요)<br>
  - 권한 검증, 패킷 처리에 따른 구조적 복잡성<br>
