---
title: "2주차 C++ 과제 2"
last_modified_at: "2025-08-12T16:00:00"
categories:
  - C++
tags:
  - C++
---

## 2주차 C++ 과제 2
C++의 다형성을 이용하여<br>
기본적인 캐릭터와 플레이어,<br>
그리고 플레이어들에 대한 전직과 몬스터를 구현하는 작업이다<br>

[Git 위치](https://github.com/hnjog/C_Task2)<br>

### 구현 요구 사안 1

- 기본 구현 사안<br>

<img width="703" height="817" alt="Image" src="https://github.com/user-attachments/assets/17b5d8de-8147-4f11-97b4-5de3be3876cb" /><br>

1. 각 전진의 부모가 될 플레이어 클래스 생성<br>
2. Attack 함수 구현<br>
3. 전직 클래스는 각각의 특징에 맞게 Attack()을 Override하여 구현<br>

### 구현 요구 사안 2

- 도전 구현 사안<br>

<img width="667" height="182" alt="Image" src="https://github.com/user-attachments/assets/f8516e74-bebc-4b79-8fda-a50a5208295e" /><br>

1. Monster 클래스를 생성<br>
2. Attack을 monster에게 하여, 대미지를 통한 전투 구현<br>

## 실제 구현 장면

- 전사 클래스 <br>

<img width="618" height="1091" alt="Image" src="https://github.com/user-attachments/assets/4ac0f73f-ba55-4e1e-b80f-765a4040bd55" /><br>

- 마법사 클래스<br>

<img width="640" height="1098" alt="Image" src="https://github.com/user-attachments/assets/cba29049-40f4-4850-9115-f8152e776e2a" /><br>

- 도적 클래스<br>

<img width="675" height="1427" alt="Image" src="https://github.com/user-attachments/assets/622a4962-9db9-43d5-ae82-89b2ffe8e4c6" /><br>

- 궁수 클래스 <br>

<img width="662" height="1265" alt="Image" src="https://github.com/user-attachments/assets/aff1a272-6eb1-48a9-869d-2a796c3d68d3" /><br>

- 몬스터한테 패배<br>

<img width="639" height="1994" alt="Image" src="https://github.com/user-attachments/assets/f5214cd4-f812-426b-862a-54c6dfb47566" /><br>


## 파일 구조
이전에 구현해둔 Task1의 기반을 가져다 사용<br>

```
클래스 구조

Character
- 체력 등의 스탯과 스킬을 관리하는 캐릭터 주체
- Stat을 Base와 Enhanced로 나누어 기본 스탯과 강화 영향을 받은 스탯으로 분류
- Attack, Hit 함수를 순수 가상함수(=0)으로 구현하여 실체화를 방지

Skill
- 대미지 비율과 마나 소모율을 관리하는 클래스
  (구조체로 구현했어도 괜찮았을듯)

Player
- Character를 상속받고 Inventory를 관리하는 Player 주체
- 전직용 Enum을 넣어두었고, Player 자신은 Nobiss(초보자)로 선언
 (실체화 자체는 가능)
- Level 변수 추가(Monster에는 필요 없으므로)

Inventory
- 포션과 같은 아이템을 추가, 사용하도록 관리하는 주체
  (다만 이번에는 사용을 하지 않는다)

Warrior, Magician, Thief, Archor
- 각각 Player를 상속받으며, 내부에서 Attack을 재정의한 자식 클래스들
- 다형성을 기반으로 MainGame에선 업캐스팅으로 Attack 호출해주면 된다

```

추가 파일들<br>

```
Utils - IsNotValid, SafeDelete 등의 매크로를 별도로 저장한 헤더 파일
Enums - Enum을 모아 놓은 헤더 파일
```

## 트러블 슈팅
~~솔직히 오늘은 없을 줄 알았다~~<br>

<img width="809" height="736" alt="Image" src="https://github.com/user-attachments/assets/7d161988-c361-4ed6-ac1c-7784c59252dc" /><br>

MainGame에서 직업별 클래스를 생성하는 중<br>
이상하게도 Warrior 클래스가 인식이 되지 않는 문제가 있었다<br>

<img width="476" height="55" alt="Image" src="https://github.com/user-attachments/assets/457522dc-0764-429a-9513-d1641c7295cd" /><br>

error는 C2061로서, 구문 오류이다<br>

<img width="293" height="150" alt="Image" src="https://github.com/user-attachments/assets/3963d500-d122-411b-9cb7-13e3e64b1526" /><br>

그런데 분명 include를 해놓았기에<br>
매우 이상한 상황이였다<br>

그렇기에 VS를 껏다 켰는데도<br>
문제가 지속되자<br>
왜 이러지 싶어서 이상하리만큼 색이 다른 Warrior에 키워드를 올린 순간...<br>

<img width="392" height="163" alt="Image" src="https://github.com/user-attachments/assets/662f2edf-53f6-494e-88f2-c10391cea5bf" /><br>

응...???<br>
Enum...????<br><br>

<img width="232" height="294" alt="Image" src="https://github.com/user-attachments/assets/30b85ef0-e255-4c40-af4a-f77d591cab6a" /><br>

~~Enum.h 또 너야?~~<br>
~~(사실 이렇게 작성한 내 잘못이다)~~<br>

전직 개념을 사용할때<br>
클래스에 대한 Enum을 통하여 실제로 Dynamic_cast를<br>
호출할만한 거리를 줄이는 것은 성능상 도움이 되기에<br>
나는 Player용 변수로 classIdx라는 Enum을 선언했었다<br>

근데 문제는 ~~멍청하게도~~ 해당 Enum과<br>
클래스 이름을 완벽하게 같이 설정해버렸다는 것...<br>

<img width="237" height="283" alt="Image" src="https://github.com/user-attachments/assets/60eb48ea-58db-446b-80a0-303e8aeee0c7" /><br>

Enum 이름을 유니크하게 설정하는 것으로 바꿔주었다<br>
문제 없이 동작한다!<br>

### Enum Class?
암묵적으로 Enum은 내부에서 int 와 같은 정수형 타입으로 처리되기에<br>
연산자를 통한 비교 등이 가능하다<br>
(ex : ClassIdx::Nobiss > ClassIdx::Archer 등)<br>

그러나 이러한 암묵적 정수 변환이 문제가 발생할 가능성이 있기에<br>
C++ 11부터 Enum class를 만들어<br>
'암묵적' 변환을 금지시켰다<br>
(Static_cast 같은 명시적 변환으론 변경 가능)<br>

대신 다른 Enum class와 이름이 같더라도<br>
'별개'의 이름으로 처리되기에 Enum끼리 이름이 같아<br>
충돌되는 현상을 방지할 수 있다<br>

### 겹치기 쉬운 Enum 이름의 처리 방식
1. 앞서 본 CLI_ 처럼 접두사나 접미사 를 만들어 겹치기 힘든 이름으로 수정
2. Enum class를 사용하기
3. namespace를 통한 분리

## 후기
어제는 분명 복잡한 기능을 넣어 시간이 낭비된 줄 알았는데<br>
막상 오늘은 어제 구현된 기능을 잘만 사용하여<br>
더 빠른 시간내로 구현이 가능하였다<br>

어찌 보면 어제 짜둔 코드가 확장성이 있기에<br>
비교적 빠르게 전직 시스템을 짤 수 있었던 것 아닐까?<br>

시스템의 구조는 여러모로 '타협'의 산물이란 것을<br>
다시 느끼는 하루다<br>