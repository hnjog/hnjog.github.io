---
title: "백준 Gold 4 숨바꼭질 2"
date : "2025-10-06 10:30:00 +0900"
last_modified_at: "2025-10-06T10:30:00"
categories:
  - 코딩 테스트
tags:
  - BFS
---

## 숨바꼭질 2 (백준 Gold 4)
<https://www.acmicpc.net/problem/12851><br>

n,k가 주어졌을때, 다음의 계산을 통하여<br>
n이 k가 되는 최소 시간과 그 경우의 수를 구하는 문제<br>

- n * 2<br>
- n + 1<br>
- n - 1<br>

## 풀이 방법

일반적인 BFS를 통해<br>
Queue를 이용하여 구할 수 있는 문제이다<br>

현재 값에 위의 수식들을 적용하면 풀 수 있으나...<br>
`메모리 초과`가 발생하기 쉽다<br>

따라서 계산을 '역'으로 해야 문제를 해결할 수 있다!<br>

`k -> n`<br>
그렇기에 수식도 변화한다<br>

- k / 2 (단, 2로 나뉘는 경우)<br>
- k - 1<br>
- k + 1<br>

해당 조건으로 풀면 queue에 너무 많은 가짓수가 들어가지 않기에<br>
메모리 초과를 피할 수 있다<br>

- 또한 중복 방문을 피하기 위하여<br>
  unordered<int,int>를 통해<br>
  방문 위치 , 최소 시간 을 통하여<br>
  가짓수를 더욱 줄였다<br>

## 제출 코드

```cpp
#include<iostream>
#include<queue>
#include<unordered_map>

using namespace std;

int main()
{
	int n, k;
	cin >> n >> k;

	// 현재 위치, 시간
	queue<pair<int, int>> q;
	unordered_map<int, int> visit;

	int bestTime = -1;
	int bestCount = 0;

	q.push({ k,0 });

	while (q.empty() == false)
	{
		int nowPos = q.front().first;
		int nowTime = q.front().second;
		q.pop();

		if (bestTime != -1 &&
			nowTime > bestTime)
			break;

		if (visit.find(nowPos) != visit.end() &&
			visit[nowPos] < nowTime)
			continue;

		visit[nowPos] = nowTime;

		if (nowPos == n)
		{
			if (bestTime == -1 ||
				nowTime == bestTime)
			{
				bestTime = nowTime;
				bestCount++;
				continue;
			}
		}

		if (nowPos % 2 == 0)
			q.push({ nowPos / 2,nowTime + 1 });

		q.push({ nowPos - 1,nowTime + 1 });
		q.push({ nowPos + 1,nowTime + 1 });
	}

	cout << bestTime << '\n';
	cout << bestCount << '\n';

	return 0;
}
```

## 결과
[![Image](https://github.com/user-attachments/assets/58e7d70f-215a-4fad-9972-5f4a0df10ac6)](https://github.com/user-attachments/assets/58e7d70f-215a-4fad-9972-5f4a0df10ac6){: .image-popup}<br>

n이 k가 되는 것은 무수히 많은 계산을 낳을 수 있으나<br>
k에서 n으로 가는 것이 더 경우의 수가 작을 수 있다는 것을 다시 한번 느꼈다<br>
(n*2 보다는 k / 2(2로 나뉜다면) 쪽이 가짓수가 줄어듦)<br>

마지막에 틀린건 혹시 첫 코드로 다시 시도해본 것!<br>
