---
title: "백준 Gold 5 A와 B"
last_modified_at: "2025-08-20T09:00:00"
categories:
  - 코딩 테스트
tags:
  - 그리디 알고리즘
---

## A와 B (백준 Gold 5)
<https://www.acmicpc.net/problem/12904><br>

처음에는 어떻게 풀지 몰라서 꽤나 고민하였다<br>


### 고민한 부분

아무리 생각해도 A에 값을 추가하여도<br>
백트래킹 문제에 가까워지며<br>
- 뒤에 A를 추가<br>
- 뒤집고 뒤에 B 추가<br>

라는 조건이 있어도<br>
그것만으로 'B'에 가까워지는지를 판별하기 어려웠다<br>

그렇다고 정말로<br>
각각의 조건을 전부 고려한 코드를 짜는 경우<br>
최악의 경우 O(2^n)이 되며<br>
목표인 b가 1000에 가까운 값이 들어올 수 있기에<br>
그렇게 구현하더라도 시간초과가 발생할 것 같았다<br>

### 생각의 전환
그렇기에 곰곰히 생각을 해본 결과<br>
'반대로 B를 A로 만드는 과정'은 어떨지에 대하여 생각해보았다<br>

그렇다면 위의 조건들은<br>
- 내 뒤에 A가 있다면 A 제거<br>
- 내 뒤에 B가 있다면 B 제거 후 뒤집기<br>

가 되며<br>
이 둘이 '불가능'하다면<br>
B는 A로 만들 수 없는 것<br>

무척 그리디한 알고리즘이 되었지만<br>
실제로 B를 A로 만든다는 것이<br>
조건을 변형하면 충분히 판별이 가능하다고 생각하였고<br>

위와는 다르게 이미 있는 B를<br>
A에 맞게 변형해가면서, 조건에 맞지 않으면<br>
바로 '포기'하면 되니<br>

충분히 괜찮은 알고리즘이라 생각하였다<br>

## 제출 코드

```
#include<iostream>
#include<string>
#include<algorithm>

using namespace std;

bool canA(string& a, string& b)
{
	if (a == b)
		return true;

	if (a.size() == b.size())
		return false;

	if (b.back() == 'A')
	{
		string t = b;
		t.pop_back();
		if (canA(a, t))
			return true;
	}

	if (b.back() == 'B')
	{
		string t = b;
		t.pop_back();
		reverse(t.begin(), t.end());
		if (canA(a, t))
			return true;
	}

	return false;
}

int main()
{
	string a, b;
	cin >> a >> b;
	cout << canA(a, b) ? 1 : 0;

	return 0;
}
```

## 결과
<img width="1157" height="161" alt="Image" src="https://github.com/user-attachments/assets/c278d4d2-2c92-40fa-aeee-af37a1382e44" /><br>

처음에 #include<algorithm>을 안해주어 컴파일 에러<br>
그 다음은 두 번째 'B'문단에서 t.pop_back()과<br>
reverse를 엇갈려 써서 첫 예제에서 0이 나온걸 그대로 제출해버렸다<br>

이후 수정하여 정답<br>

발상의 전환이 중요한 문제였다<br>
