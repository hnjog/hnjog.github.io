---
title: "백준 Silver 1 카드 구매하기"
date : "2025-08-22 09:00:00 +0900"
last_modified_at: "2025-08-22T09:00:00"
categories:
  - 코딩 테스트
tags:
  - DP
---

## 카드 구매하기 (백준 Silver 1)
<https://www.acmicpc.net/problem/11052><br>

민규가 모으는 카드의 개수는 n개이며<br>
n개의 카드가 들어있는 n개의 카드팩의 가격이 주어진다<br>

민규는 이상한? 미신을 믿고 있기에<br>
가능하면 n개의 카드를 구매하기 위하여<br>
가장 많은 돈을 사용하려 한다<br>

민규가 n개의 카드를 구매할 때의<br>
가장 큰 비용을 구하는 문제<br>

### 풀이 방식
일단 dp 문제이기에 점화식을 세우는 것을 목표로 하였다<br>
(n개 구매를 목표로 할때, 다른 n-1개 등의 값을 재활용이 가능해 보였으므로)<br>

점화식 정의<br>
dp[n] : n개의 카드를 모을때 사용하는 가장 큰 가격<br>

초기 조건<br>
dp[0] = 0 : 0개의 카드는 돈이 필요 없으므로<br>
dp[1] = cards[1] : 1개의 카드만 필요하다면 첫번째 카드팩만 구매해야 함<br>

그렇기에<br>
dp[2] = max(cards[2],dp[1] + dp[1]) 이라고 생각하였다<br>

조금 더 생각해보니<br>
'이전 값'을 더하는 것은 맞지만<br>
n개의 '카드'를 모으려면 사실<br>
1~n까지 돌았을 때<br>

dp[3] = cards[3] , dp[2] + dp[1]<br>
dp[4] = cards[4] , dp[1] + dp[3], dp[2] + dp[2]<br>
...<br>

인것으로 보아<br>

dp[n] = cards[n] , dp[1] + dp[n-1], dp[2] + dp[n-2]...<br>
가 되는 것을 판별할 수 있었다<br>

따라서 dp[n] 의 초기값을 cards[n]으로 놓은 후<br>
1~n까지 돌면서 dp[j] + dp[i-j]를 돌리면 되겠다 싶었다<br>
(실제로는 n/2 까지만 돌면 된다)<br>

완성된 점화식<br>
dp[n] = max(cards[n], for(1~n/2) max(dp[n],dp[j] + dp[i-j]))<br>

## 제출 코드

```
#include<iostream>
#include<vector>

using namespace std;

int main()
{
	int n;
	cin >> n;
	vector<int> cards(n + 1);
	for (int i = 1; i <= n; i++)
		cin >> cards[i];

	vector<int> dp(n + 1);
	dp[0] = 0;
	dp[1] = cards[1];

	for (int i = 2; i <= n; i++)
	{
		dp[i] = cards[i];

		for (int j = 1; j <= i / 2; j++)
		{
			dp[i] = max(dp[i], dp[i - j] + dp[j]);
		}
	}

	cout << dp[n];

	return 0;
}
```

## 결과
<img width="1165" height="92" alt="Image" src="https://github.com/user-attachments/assets/e1e69dda-c4c0-45ff-90ad-6f168ca66d18" /><br>

이번 문제는 점화식을 잘 세울 수 있었다<br>