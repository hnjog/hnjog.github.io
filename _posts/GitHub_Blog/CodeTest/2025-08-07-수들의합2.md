---
title: "백준 Silver 4 수들의 합 2"
last_modified_at: "2025-08-07T08:00:00"
categories:
  - 코딩 테스트
tags:
  - 누적합
  - 투 포인터
---

## 수들의 합 2  (백준 Silver 4)
<https://www.acmicpc.net/problem/2003><br>

투 포인터 + 누적합의 문제로<br>
누적합을 통하여<br>
수열의 값을 요소의 총합으로 저장한 후(sums),<br>
이후 j~i 까지의 합을 구할 때<br>
그 차이를 빼줌으로서(sums[i] - sums[j])<br>
빠르게 합을 구하며<br>
수열 내의 '합'이 특정한 값 M 인 경우의 수를 구하는 방식이다<br>

'투 포인터'를 이용하여<br>
인덱스 i와 j를 적절히 이동시켜 값을 구한다<br>

nowSum = sums[i] - sums[j];<br>
라 한다면 그 합이<br>
m이라면 정답 카운트를 + 1<br>
m보다 작다면 i를 올려 총 합을 크게<br>
m보다 크다면 j를 올려 총 합을 작게<br>
만드는 방식이다<br>

### 처음 제출한 코드

```
#include<iostream>
#include<vector>

using namespace std;

int main()
{
	vector<int> ip;
	int n, m;
	cin >> n >> m;

	for (int i = 0; i < n; i++)
	{
		int t;
		cin >> t;
		ip.push_back(t);
	}

	int answer = 0;
	vector<int> sums(n,0);
	sums[0] = ip[0];
	for (int i = 1; i < n; i++)
	{
		sums[i] = sums[i - 1] + ip[i];
		if (sums[i] == m)
		{
			answer++;
		}
	}

	int i = 1, j = 0;
	
	while (i < n)
	{
		int nowSum = sums[i] - sums[j];

		if (nowSum == m)
		{
			answer++;
			i++;
			j++;
		}
		else if (nowSum > m)
		{
			j++;
		}
		else
		{
			i++;
		}

	}

	cout << answer;
}
```

## 무엇을 고려하지 못하였을까?

1. 일단 누적합을 다소 잘못 구하였다<br>
   Sums[i] -Sums[i-1] 처럼 값 차이가 1이 나오는 경우<br>
   i번째 요소값을 return 해야 하는데<br>
   그 부분을 고려하지 못했다<br>
   따라서 sums를 n+1로 잡은 후<br>
   sums[0] 을 0으로 잡는 방식으로 바꾸었다<br>

2. i가 n에 도달하면 j가 어디있든 반복문이 종료한다<br>
   i가 n에 도달하더라도 j가 n까지 올라오며<br>
   합의 값이 m일 수 있는 경우의 수를 포함하지 못한다<br>
   따라서 반복문의 종료 조건을 수정하였고<br>
   i가 이미 최대치라면 대신 j를 올리는 방식으로 수정하였다<br>


<img width="1165" height="138" alt="Image" src="https://github.com/user-attachments/assets/0a4f7e1c-3733-42ac-b740-e6161bc212ca" />

---

### 최종 제출 코드

```
#include<iostream>
#include<vector>

using namespace std;

int main()
{
	vector<int> ip;
	int n, m;
	cin >> n >> m;

	for (int i = 0; i < n; i++)
	{
		int t;
		cin >> t;
		ip.push_back(t);
	}

	int answer = 0;
	vector<int> sums(n + 1, 0);
	sums[0] = 0;
	for (int i = 1; i <= n; i++)
	{
		sums[i] = sums[i - 1] + ip[i-1];
	}

	int i = 1, j = 0;

	while (true)
	{
		int nowSum = sums[i] - sums[j];

		bool bOveri = false;

		if (i >= n)
			bOveri = true;


		if (nowSum == m)
		{
			answer++;

			if (bOveri == false)
				i++;
			else
				j++;
		}
		else if (nowSum > m)
		{
			j++;
		}
		else
		{
			if (bOveri == false)
				i++;
			else
				j++;
		}

		if (i >= n && j >= n)
			break;
	}

	cout << answer;
}
```