---
title: "백준 Gold 5 합분해"
date : "2025-09-12 11:00:00 +0900"
last_modified_at: "2025-09-12T11:00:00"
categories:
  - 코딩 테스트
tags:
  - 수학
  - 다이나믹 프로그래밍
---

## 합분해 (백준 Gold 5)
<https://www.acmicpc.net/problem/2225><br>

0~N 까지의 정수를 k개 더하여 그 합이 N이 되는<br>
경우의 수를 구하는 프로그램<br>

## 풀이 방법
중복된 값을 이용하는 것이 보였으므로 dp를 이용하였다<br>
그리고 top - down 방식으로 풀었다<br>

점화식을 세우자면<br>
dp[n][k] : k개를 더하여 n이 되는 경우의 수<br>

기저 조건<br>
dp[n][0] = 0 : 0개를 더하여 가능한 수는 없음 <br>
dp[n][1] = 1 : 1개를 고른다면 자기 자신 밖에 없음<br>

또한 각 수들은<br>
0 + n, 1 + n - 1, 2 + n-2, ..., n - 1 + 1, n + 0 같이<br>
순서가 바뀌어도 셀 수 있음<br>

- 특정한 한 자리의 값이 i라면 나머지는 n-i가 되어야<br>
  n이 된다<br>
- 여기에 k번째 수임을 고려한다면<br>
  i 가 결정되었을때 k-1에 대한 수로 n-i를 구해야 함<br>

- 따라서 반복문의 i로 수를 고정시키고<br>
  다시 재귀를 돌려 n - i 가 k-1 로 만들어지는 경우의수를 구함<br>

- dp[n][k]는<br>
  : 0~n 까지의 k-1의 합<br>
   dp[n][k] = for(i : 0 ~ n) dp[i][k-1]<br>
   (사실 dp[n-i][k-1]이 더 위의 식의 의미에 걸맞긴 하다)<br>

## 제출 코드

```cpp
#include<iostream>
#include<vector>

using namespace std;

const int divV = 1000000000;

long dp[201][201] = {0,};

long recur(int n,int k)
{
	if (k == 0)
		return 0;

	if (k == 1)
		return 1;

	if (dp[n][k] != 0)
		return dp[n][k];

	for (int i = 0; i <= n; i++)
	{
		dp[n][k] += recur(i, k - 1);
		dp[n][k] %= divV;
	}

	return dp[n][k] % divV;
}

int main()
{
	int n, k;
	cin >> n >> k;

	cout << recur(n,k);

	return 0;
}
```

## 결과
[![Image](https://github.com/user-attachments/assets/8e969205-6b0c-4d37-88e5-1344bb550a66)](https://github.com/user-attachments/assets/8e969205-6b0c-4d37-88e5-1344bb550a66){: .image-popup}<br>

divv로 값을 나누지 않고,<br>
또 int의 오버 플로우일 가능성이 있어<br>
그냥 안전하게 long으로 선언하니<br>
해결되었다<br>