---
title: "백준 Gold 2 문제집"
date : "2025-10-22 10:30:00 +0900"
last_modified_at: "2025-10-22T10:30:00"
categories:
  - 코딩 테스트
tags:
  - 위상정렬
  - 우선순위 큐
---

## 문제집 (백준 Gold 2)
<https://www.acmicpc.net/problem/1766><br>

주어지는 문제집을 효율좋게 푸는 문제<br>

- 문제집은 난이도 순서대로 총 n개 주어짐<br>

- 먼저 푸는게 효율적인 정보가 m가 주어지며<br>
  먼저 푸는게 좋은 문제가 있는 문제는<br>
  `반드시` 그 문제를 풀고 올 것<br>

- 먼저 풀만한 문제가 없는 경우<br>
  가능한 쉬운 문제부터 풀을 것<br>

## 풀이 방법

`위상정렬` 문제이나<br>
입력 차수가 0이여도 '문제의 난이도'에 따라<br>
정렬이 필요한 문제<br>

그렇기에 일반적인 queue 대신<br>
우선순위 큐를 사용하여 문제를 풀 수 있다<br>

## 제출 코드

```cpp
#include<iostream>
#include<vector>
#include<queue>

using namespace std;

struct node
{
	int idx;
	int degree;
	vector<int> next;
};

struct Compare
{
	bool operator()(const node& a, const node& b)
	{
		if (a.degree == b.degree)
			return a.idx > b.idx;

		return a.degree < b.degree;
	}
};

int n, m;

void Topo(vector<node>& nVec)
{
	priority_queue<node, vector<node>, Compare> pq;
	for (node& n : nVec)
	{
		if (n.degree == 0)
			pq.push(n);
	}

	while (pq.empty() == false)
	{
		node n = pq.top();
		pq.pop();

		cout << n.idx + 1 << ' ';

		for (int next : n.next)
		{
			nVec[next].degree--;
			if (nVec[next].degree == 0)
				pq.push(nVec[next]);
		}
	}
}

int main()
{
	cin >> n >> m;

	vector<node> nVec(n);
	for (int i = 0; i < n; i++)
	{
		nVec[i].idx = i;
		nVec[i].degree = 0;
	}

	for (int i = 0; i < m; i++)
	{
		int s, t;
		cin >> s >> t;
		s--;
		t--;
		nVec[s].next.push_back(t);
		nVec[t].degree++;
	}

	Topo(nVec);

	return 0;
}
```

## 결과
[![Image](https://github.com/user-attachments/assets/f18c686a-e67c-4a0c-b2f0-99de5bf00f53)](https://github.com/user-attachments/assets/f18c686a-e67c-4a0c-b2f0-99de5bf00f53){: .image-popup}<br>

사실 degree가 0일때만 pq에 넣기 때문에<br>
degree 관련 부분은 Compare 부분에서 적용하지 않아도 되지 않았을까 싶다<br>