---
title: "백준 Silver 2 가장 큰 증가하는 부분 수열"
last_modified_at: "2025-08-21T09:00:00"
categories:
  - 코딩 테스트
tags:
  - DP
---

## 가장 큰 증가하는 부분 수열 (백준 Silver 2)
<https://www.acmicpc.net/problem/11055><br>

LIS 중 '가장 합'이 큰 수열의 그 합을 구하는 문제<br>

### 풀이 방식
점화식 정의<br>
DP[n] : n을 포함하는 가장 큰 증가하는 부분 수열의 값<br>

따라서 DP[n]은 n->0 까지 돌며<br>
이전 노드 중<br>
자신보다 '수열의 값'이 작은 노드를 찾고<br>

DP[n] = max(DP[n], DP[Target] + 수열 N의 값)<br>
을 적용하면 된다<br>

이걸 1-> n까지 반복하며<br>
마지막에 dp에서 max_element를 통해 최댓값을 구한다<br>
(실제로는 각 요소들에 대한 반복문은 한번만 돌기에<br>
시간 복잡도는 O(N^2)가 된다)<br>

(재귀 * 재귀 외부에서 각 요소를 반복문)<br>

(ex : dp[n] -> recur(target)인 경우<br>
target은 n보다 작으며 이미 dp를 구해놓음)<br>

## 제출 코드

```
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int recur(const vector<int>& vec, vector<int>& dp,int start)
{
	if (start < 0)
		return 0;

	if (dp[start] != 0)
		return dp[start];

	dp[start] = vec[start];
	
	for (int i = start - 1; i >= 0; i--)
	{
		if (vec[start] > vec[i])
		{
			// start가 자신 이전 위치에서
			// 자신보다 낮은값 발견 시,
			// 그 dp값을 자신에게 더함
			dp[start] = max(dp[start], recur(vec, dp, i) + vec[start]);
		}
	}

	return dp[start];
}

int main()
{
	int n;
	cin >> n;
	vector<int> vec(n);
	for (int i = 0; i < n; i++)
		cin >> vec[i];

	// 가장 '합'이 큰 LIS 의 합 구하기
	vector<int> dp(n);
	dp[0] = vec[0];

	// start = 0 ~ n까지 진행
	for (int i = 1; i < n; i++)
		recur(vec, dp, i);

	cout << *max_element(dp.begin(), dp.end());

	return 0;
}
```

## 결과
<img width="1162" height="125" alt="Image" src="https://github.com/user-attachments/assets/21b6b55c-173f-4543-bad3-f1c201908730" /><br>

컴파일 에러는 include를 하지 않았기에....<br>
(max_element)<br>

LIS 는 DP 강의를 들을 때<br>
푸는 법을 기억해 놓았기에 다행히 어렵지 않게 풀 수 있었다<br>