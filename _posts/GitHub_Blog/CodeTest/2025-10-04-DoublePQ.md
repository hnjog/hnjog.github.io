---
title: "백준 Gold 4 이중 우선순위 큐"
date : "2025-10-04 10:30:00 +0900"
last_modified_at: "2025-10-04T10:30:00"
categories:
  - 코딩 테스트
tags:
  - 맵
---

## 이중 우선순위 큐 (백준 Gold 4)
<https://www.acmicpc.net/problem/7662><br>

'이중 우선순위 큐'라는 자료구조가 존재할때<br>
최소값과 최댓값을 구하는 문제<br>

조건<br>
- 연산은 I와 D가 주어지며<br>
  I는 삽입<br>
  D는 -1,1에 따라 각각<br>
  최솟값, 최댓값 삭제이다<br>
  (I로 중복된 값이 들어올 수 있음)<br>

- 큐가 비어있다면 D 연산은 무시<br>

- 최종적으로 큐가 비어있다면 `Empty`를<br>
  그렇지 않다면 최댓값, 최솟값을 출력<br>

## 풀이 방법

처음에는 정말로 2개의 우선순위 큐를 사용하여 문제를 풀어보려 하였으나<br>
곧바로 문제에 부딪혔다<br>

- 각각의 큐가 중복된 값을 가지면 처리하기 까다로움<br>

- 그렇다면 최소 큐 + 최대 큐 를 나누어 데이터를 관리?<br>
  - 최소 큐에 작은 값, 최대 큐에 큰 값을 집어넣으면<br>
    D와 정답 처리는 편하지만 I 를 통한 각 큐의 데이터 교환이<br>
	힘들어짐<br>
  - 그렇다고 반대로 하자니, D와 정답 처리가 까다로워 짐<br>

그렇기에<br>
생각을 바꾸어 보았다<br>

- 정렬이 되어야 하면서, 최대 값, 최소값에 대한 접근이 비교적 가벼운 자료구조<br>
- 중복된 값을 고려하는 자료구조<br>

생각해보니 `std::map`이면 충분히 가능해보였다<br>

- map은 자체적으로 정렬되므로 begin, rbegin을 통해 각각의 요소에 접근 가능<br>
- Insert도 `O(log n)` 정도이고 최대 100만개 정도까지는 가능해보임<br>
- Delete 역시 `O(log n)` 정도이고, 접근도 `O(log n)`<br>

따라서 map으로 구현하여 문제를 풀었다<br>

## 제출 코드

```cpp
#include<iostream>
#include<map>
#include<string>

using namespace std;

int main()
{
	int t;
	cin >> t;

	while (t > 0)
	{
		int n;
		cin >> n;

		map<int, int> ms;

		for (int i = 0; i < n; i++)
		{
			char c;
			int v;
			cin >> c >> v;

			if (c == 'I')
			{
				ms[v]++;
			}
			else if(ms.empty() == false)
			{
				int tar = 0;
				if (v == 1)
				{
					tar = ms.rbegin()->first;
				}
				else
				{
					tar = ms.begin()->first;
				}

				ms[tar]--;
				if (ms[tar] == 0)
					ms.erase(tar);
			}
		}

		if (ms.empty())
			cout << "EMPTY" << '\n';
		else
			cout << ms.rbegin()->first << " " << ms.begin()->first << '\n';

		t--;
	}


	return 0;
}
```

## 결과
[![Image](https://github.com/user-attachments/assets/8a32e72b-dd17-4e60-a03f-753018c2525c)](https://github.com/user-attachments/assets/8a32e72b-dd17-4e60-a03f-753018c2525c){: .image-popup}<br>

문제의 제목에 우선순위 큐 이기에<br>
pq 관련 문제인줄 알았지만, map으로 충분히 풀 수 있는 문제였다<br>