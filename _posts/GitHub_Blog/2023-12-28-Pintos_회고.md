---
title: "Pintos 회고"
last_modified_at: "2023-12-28T15:00:00"
categories:
  - 크래프톤 정글
  - Pintos
tags:
  - 크래프톤 정글
  - Pintos
---

## Pintos Project3 까지...
 OS가 얼마나 대단하고 소중한 (?) 존재인지 깨달을 수 있었던<br>
 5주였던 것 같다<br>
 각각 스케쥴링, 시스템 콜, 가상 메모리 에 대한<br>
 OS의 핵심적인 역할에 대하여 보다 심도있게 이해할 수 있었다<br>
 
 이전에야<br>
 CS 적인 지식을 익히고<br>
 'OS가 하드웨어와 사용자 프로그램 사이의 다리 역할을 해주는구나~'라고 이해하였지만<br>
 실제로 직접 구현을 해보니 OS 역시<br>
 하나의 '프로그램'이며<br>
 주어진 '로직'에 따라서 동작한다는 것을 실감할 수 있었다<br>
 
## Project1. Scheduel
 타이머 인터럽트 및 OS의 스케쥴링 알고리즘에 대하여 구현하였던<br>
 부분이다<br>

 타이머 인터럽트를 통해, 하나의 '프로세스'가<br>
 cpu를 지속적으로 사용하는 문제를 예방하는 '보호 & 고립'에 대하여 조금 더 인식할 수 있었고<br>

 스케쥴링 방식으로 '우선순위'를 통하여<br>
 프로그램의 '반응' 및 '완료' 시간의 최적화에 대하여 생각해볼 수 있었다<br>

## Project2. System Call
 'System Call'에 대하여 한층 더 이해할 수 있었는데<br>
 특히 '디버깅'이 제대로 되지 않았던 점이 흥미로웠다<br>

 'User Program'이 현재 작동하고 있는 시점을 명확히 알 수 없는<br>
 OS적인 입장에서 디버깅을 하였기에<br>
 실제 OS는 'User Program'이 어떠한 호출을 하더라도<br>
 그 '내용'과 관련없이 요구된 동작을 처리하고<br>
 결과를 돌려준다는 점이 인상 깊었다<br>

## Project3. Virtual Memory
 현재까지 해본 코드 중 하드웨어와 가장 밀접하게<br>
 코드를 짯던 경험이 되었다<br>

 User Program을 필요에 따라<br>
 'User Pool' 에 해당하는 메모리에 넣어주고<br>
 필요에 따라서<br>
 해당 프로세스의 Stack 크기를 늘려주는 등의<br>
 작업을 하였으며<br>

 가장 크게 느낀 점은<br>
 '선형'으로 되어있다고 User Program에서 사용하지만<br>
 실제로는 DRAM에서 연결된 '프레임'을 찾아<br>
 사용하고 있었던 부분이었다<br>

 이러한 가상 메모리에 대한 구현 부분을 공부함으로서<br>
 '추상화'의 강력함을 다시 깨달을 수 있었다<br>
 (사용자 프로그램은 'DRAM'의 어느 부분이 사용 가능한지<br>
  알 필요가 없지 않은가!)<br>
 
## 정리
 사실 PintOS를 공부하며<br>
 '이걸 어디에 쓰지?'의 물음이 들었을 때는<br>
 명확히 답변을 하지 못할지도 모르겠다<br>

 그러나, 우리가 '간편하게' 사용 중인<br>
 프로그램이 실제 컴퓨터 내부적으로<br>
 어떻게 동작하는지<br>
 특히 'OS'가 우리의 일을 어떻게 처리하는지를<br>
 조금 더 잘 이해하게 된 부분이 존재한다<br>

 추가적으로 '가상 메모리'의 디자인 방식은 아주 인상깊었다<br>
 
 => 프로세스는 각각 '별도'로 분리되어 있다는 착각을 가지며<br>
 이에 따라 '같은 가상 주소'를 사용하더라도 OS가 '알아서'<br>
 물리 메모리에 산발적으로 배치해준다<br>
 (Page Table을 참고하여 실제 메모리에 존재하는 것을 참고하고<br>
 Page Fault를 통해 현재 메모리에 적재되어 있지 않으면 가져온다)<br>

 내가 직접 '알아서' 부분을 구현해본 것은<br>
 아주 고되었지만<br>
 프로세스의 Page Table과 그에 따른 Swap In/Out이 어떻게 돌아가는지 구현해본 것은<br>
 실제로 프로그램이 필요한 메모리에 대한 요청이 OS단에서 처리되는지<br>
 납득이 되도록 이해할 수 있었다<br>

 
