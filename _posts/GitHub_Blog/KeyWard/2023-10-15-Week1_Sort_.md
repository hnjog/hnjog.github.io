---
title: "정렬"
last_modified_at: "2023-10-15T15:00:00"
categories:
  - 크래프톤 정글
tags:
  - 크래프톤 정글
  - 키워드
  - 정렬
---

## 정렬 알고리즘
 n개의 데이터가 입력으로 주어졌을 때, <br>
 특정한 기준에 따라 해당하는 데이터에 순서대로 열거하는 것<br>
 데이터를 정렬하는 경우 효율적인 '탐색'이 가능해진다<br>

 안정성
 : 정렬할 데이터(원본)의 '반복'되는 요소를 받은 그대로 처리하는 경우는 <b>'안정 정렬'</b> 이라 한다.<br>
   반대로 뒤섞일 가능성이 있다면 <b>'불안정 정렬'</b>이라 한다.

## 알고리즘의 종류
 정렬 알고리즘의 종류는 다양하나,<br> 여기서는 아래의 알고리즘들을 소개해볼까 한다<br>
 - 삽입정렬
 - 퀵정렬   (Quick sort)
 - 병합정렬 (merge sort)
 - 힙정렬   (heap sort)

## 삽입정렬
 ![test](https://user-images.githubusercontent.com/43630972/275307101-5f4bfa39-a858-4537-b903-50b947fd1600.gif){: width="50%" height="50%"}<br><br>
 k번째 원소를 1~(k-1)의 원소와 비교하여<br>
 적절한 위치에 '삽입'한 뒤, 그 뒤의 원소들을 뒤로 미루는 정렬이며 '안정 정렬'이다.<br><br>
 
 <b>시간 복잡도 (평균) : </b> O(n^2) <br>
 <b>시간 복잡도 (최선) : </b> O(n) (이미 정렬이 되어 있는 경우)<br><br>

 '이미 어느정도 정렬된' 배열에서 사용하기 유용한 알고리즘<br>
 (해당 부분에 한하여 O(n)에 해당하는 복잡도를 가지게 되므로)

## 퀵 정렬
 ![test](https://user-images.githubusercontent.com/43630972/275309480-a79dd221-f799-4687-a219-7b6e071bc6fd.png){: width="75%" height="75%"}<br><br>
 데이터에서 임의의 값을 기준값(pivot)으로 정한뒤, 2개의 집합으로 나눈다.<br>
 기준값보다 작은 쪽과 큰 쪽으로 나눈뒤,<br>
 각각의 집합에서 기준값을 만들고 다시 위의 내용을 실행한다.<br>
 더 이상 집합을 나눌 수 없을때까지 반복하면 된다<br>
 퀵 정렬은 '불안정 정렬'이기에,<br> 정렬 이후의 원본과의 '반복 요소'의 순서가 변할 수 있는 점을 유의해야 한다<br>

 <b>시간 복잡도 (평균) : </b> O(n log n) <br>
 <b>시간 복잡도 (최악) : </b> O(n^2) <br>(배열이 이미 정렬되어 있는 상황에서 사용하거나,<br> 임의의 기준값을 선택할 때, 최솟값, 최댓값을 반복적으로 선택하는 경우 발생 가능)<br><br>

 퀵정렬 진행방식
 : ![test](https://user-images.githubusercontent.com/43630972/275309235-cc955a3b-28f3-4bfa-874e-a6281cc20c2e.png){: width="30%" height="30%"}<br><br>

 가장 많이 사용되는 정렬 알고리즘?
 : 퀵 정렬의 루프 방식이 대부분의 컴퓨터 아키텍처에서 효율적으로 동작하게 설계되어 있다<br>
   (메모리 참조가 지역화되어 있기때문에 CPU 캐시의 히트율이 높아지기 때문)<br>
   데이터가, 점점 좁은 범위에서 서로 교환되며,<br> 이는 캐시를 통해 해당 데이터를 가져올 확률이 올라가게 된다!<br>
   따라서 퀵 정렬은 같은 시간 복잡도를 가졌더라도, 다른 정렬에 비하여 캐쉬의 도움을 받을 가능성이 높다!<br><br>
   (지역화 : CPU가 짧은 시간 내에 일정 구간의 메모리 영역을 반복적으로 엑세스하는 경향)<br>

## 병합정렬
 ![test](https://user-images.githubusercontent.com/43630972/275307139-dfffebd2-87f2-48d5-b783-ed7547eb511d.gif){: width="50%" height="50%"}<br><br>
 병합 정렬은 '분할 -> 정렬 -> 결합'의 순서로 이루어지는 정렬 알고리즘이다.<br>
 - 분할
  : 데이터 배열을 2개 이상의 부분 배열로 '분할'한다
 - 정렬
  : 부분 배열 내부 요소들끼리 '정렬'한다 
 - 결합
  : 해당하는 부분 배열들을 '결합' 한다 <br>
    이후 '정렬' -> '결합'을 반복하여 데이터 배열 전체가 정렬된다
  
 <b>시간 복잡도 (평균,최선,최악) : </b> O(n log n) <br>
 항상 일정한 시간 복잡도를 유지하고 '안정 정렬'인 특징이 있으나,<br>
 정렬을 위한 추가적인 배열 공간을 사용하는 점 또한 유의해야 한다.<br><br>

## 힙정렬
 ![test](https://user-images.githubusercontent.com/43630972/275307182-58ccb2b1-6378-4f45-9398-51c1bb37090c.gif){: width="50%" height="50%"}<br><br>
 '힙 트리'를 구성해 정렬을 하는 방법<br>
 배열 요소들로 '완전 이진 트리'를 구현하고,<br>
 (오름차순,내림차순에 따라 각각 최소 힙, 최대 힙으로 구성)<br>
 이후 힙에서 하나씩 요소를 꺼내어 배열의 뒤부터 저장<br>
 (요소가 하나 줄어들면 힙트리가 다시 '정렬'된다)

<b>시간 복잡도 (평균,최선,최악) : </b> O(n log n) <br>
 항상 일정한 시간 복잡도를 유지하는 점이 특징<br>
 가장 특징적(최댓,최소)인 데이터 몇 개가 필요할 때 유용한 알고리즘<br>
 ('힙 트리'의 앞부분만 빼내 쓸 수 있으므로)

## GIF 출처
  [GIF 이미지 출처 : J Stroy ]<https://aiday.tistory.com/53>