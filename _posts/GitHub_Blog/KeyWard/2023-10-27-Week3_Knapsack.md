---
title: "Knapsack Problem"
last_modified_at: "2023-10-27T14:20:00"
categories:
  - 크래프톤 정글
tags:
  - 크래프톤 정글
  - 키워드
  - 최적 부분 구조
  - 동적 계획
  - 탐욕
---

## 배낭 문제 (Knapsack Problem)
  한정된 용량에 일정한 '가치'와 '용량'을 가지는 물건을 넣어<br>
  가치가 '최대'가 되도록 배낭을 채우는 문제<br>

  여러 변형이 존재하지만 크게 2가지 유형으로 볼 수 있다<br>
  1. 0/1 배낭 문제<br>
  : '물건'은 배낭에 '넣거나 넣지 않거나'만 선택 가능<br>
  해당 문제는 'DP'로 풀 수 있다<br>
  (이 경우의 시간 복잡도는 O(n^2)<br>
  정확히는 배낭과 물건의 곱이다)

  2. 분할 가능 배낭 문제 (Fractional Knapsack)<br>
  : 물건의 '일부'를 잘라 배낭에 넣을 수 있는 문제<br>
  해당 문제는 '그리디' 방식으로 풀 수 있다<br>
  (이 경우의 시간 복잡도는 O(n logN)이며<br>
  '용량 대비 가치'로 물건을 선택(정렬)하기에 logN의 시간복잡도가<br>
  필요하다)

  일반적인 방법으로 푼다면 O(2^n)의 시간복잡도를 가지기에<br>
  문제의 유형에 따라서 필요한 알고리즘을 선택해서 푼다

## 배낭 문제의 해법
 ![lcs](https://user-images.githubusercontent.com/43630972/278551516-87179ece-a8b7-40ef-bc9c-46ede4155968.png){: width="50%" height="50%"}<br><br>
 [출처] : <https://gsmesie692.tistory.com/113><br><br>

 가치 테이블 P가 있다고 가정하고<br>
 보석의 인덱스를 i,<br>
 현재 배낭의 무게를 w로 한다면<br>
 1. i 보석을 집어넣을 때,<br>
    그 무게(wi)가 배낭을 넘는다면, 이전 값을 넣는다<br>
    p[i,w] = p[i-1,w]
 2. 그렇지 않다면, 이전값과 p[i-1,w-wi]의 값과 비교(이전 단계의, 해당 무게를 제한 가치)<br>
    둘 중 높은 가치를 가진쪽을 p[i,w]에 넣어준다<br>
    p[i-w] = max(vi + p[i-1,w-wi], p[i-1,w])

  해당 방식을 이용한 '상향식(bottim - up)' 방식으로




## 문재 이해에 도움이 된 사이트
 - https://gsmesie692.tistory.com/113