---
title: "Process 와 Thread"
last_modified_at: "2023-11-23T15:20:00"
categories:
  - 크래프톤 정글
  - CS
  - OS
tags:
  - 크래프톤 정글
  - CS
  - OS
  - PintOS
  - 프로세스
  - 스레드
---

## 운영체제의 개요
 OS란 뭘까?<br>
 일단 프로그램은 '명령어의 집합'이라고 봐도 과언이 아닐것이다<br>
 
 폰 노이만 구조에서<br>
 프로그램의 각 명령어는<br>
 Fetch(가져오기) : PC(프로그램 카운터)에 저장된 메모리 주소에서 명령어를 가져온다<br>
 Decode(해독) : 가져온 명령어를 해독하여 실행할 작업을 결정<br>
 Execute(실행) : 해독된 작업(연산)을 수행한다<br>
 를 의미한다<br>

 이러한 '프로그램'을 쉽게 실행(다수도 동시에!)하게 하며,<br>
 프로그램 간의 메모리 공유를 가능하게 하며,<br>
 하드웨어와의 상호작용을 가능하게 하는 소프트웨어를 OS라 한다<br>
 => 시스템을 사용하게 편하게 해준다<br>

 - 폰 노이만 구조<br>
   : 입/출력 장치, 메모리(저장 장치), 처리 장치 (CPU) 로 구성된<br>
     구조로 메모리에서 데이터를 읽어 처리 장치가 처리하는 구조를 가진다<br>
     (메모리에 '프로그램'이 저장되어 있기에 '프로그램 내장식 구조'라는 표현으로도<br>사용된다)<br>

## 운영체제와 '가상화'
 운영체제는 위에서 언급한 다양한 일을 수행하기 위해 '가상화'라는 기법을 사용한다<br>

 '프로세서(CPU), 메모리(DRAM), 디스크(HDD or SSD)' 와 같은 물리적인 자원을 이용해<br>
 일반적이고, 사용이 편리한 '가상'의 자원을 생성한다<br>
 (이러한 이유로 OS를 '가상머신'(Virtual machine) 이라고도 한다)<br>

 사용자 프로그램이 '프로그램 실행', '메모리 할당', '파일 접근'과 같은<br>
 '가상 머신'과 관련된 기능을 OS에 요청할 수 있도록<br>
 OS는 사용자에게 API(Application Programming Interface)를 제공한다<br>
 (상호작용할 수 있도록 제공하는 일종의 인터페이스)<br>

 운영체제는 사용자 프로그램이 사용 가능한 '시스템 콜'을 제공한다<br>
 ('실행', '메모리 및 하드웨어 접근' 등에 대한 시스템 콜을 제공하기에<br>
 '표준 라이브러리'를 제공한다 표햔하기도 한다)<br>

 '가상화'는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있도록 하기에<br>
 운영체제를 '자원 관리자(resource manager)'라고도 부른다<br>
 (CPU, 메모리 및 디스크는 시스템의 자원이다)<br>
 
 이러한 자원을 효율적이고 공평하게 관리하는 것도 OS의 역할이다<br>

 - CPU 가상화<br>
   : 동시에 많은 프로그램이 실행될 수 있도록 하는 일종의 '환상'이다<br>
     (마치 여러 CPU가 존재하는 것처럼 다양한 프로그램이 동시에 실행)<br>
     이를 위해 '도구'와 '정책'이 필요하다<br>

 - 메모리 가상화<br>
   : 컴퓨터 하드웨어는 '물리적인 주소'(즉, 바이트의 배열)를 사용한다<br>
     그렇기에 우리가 메모리에 접근하여 '읽거나 쓰려면' 이러한 주소를 알아야 한다<br>
     그렇지만 우리가 프로그램을 만들 때, '해당 프로그램'이 어느 위치에 존재할지를<br>
     유념하고 코딩하지 않는다<br>
     => 이것이 '메모리 가상화'이며, 각 프로세스는 자신만의 '가상 주소 공간'을 가진다<br>
        이러한 가상 주소 공간을 관리하며, 서로 침범하지 못하게 하는 것도 OS의 역할이다<br>

## 운영체제가 프로그램 시작을 위해 진행하는 것들
 프로그램 시작을 위해...<br>
 즉, '프로세스'를 생성하기 위해 운영체제가 하는 행위들을 먼저 짚고 넘어가려 한다<br>

 1. 프로그램 코드와 정적 데이터(static data)를 메모리, 프로세스 의 주소 공간에 탑재<br>
 2. 스택(런타임 스택), 힙 영역 할당<br>
 (tmi : main 함수의 인자인 argc, argv 를 사용하여 스택을 초기화 한다)<br>
 3. 입출력 초기화<br>
 (tmi : 유닉스는 stdin, stdout, stderr 에 해당하는 파일 디스크립터를 가짐)<br>
 4. 이제, main()에서 (즉, 프로그램의 entry point)<br>
    프로그램 실행을 시작한다

## 프로세스(Process)
 OS 수준에서의 '프로그램'에 대한 추상화(By CSAPP)<br>
 '실행 중인 프로그램'의 인스턴스라고도 표현된다<br>

 OS는 '여러 프로세스를 동시에' 실행시키는 요구를 받고 있으며<br>
 (주로 사용자가 요청하며, 이것이 CPU 가상화를 요구한다)<br>
 그러한 요청을 만족하기 위하여<br>
 '도구(Mechanism)' 와 '정책(Policy)'가 필요하게 되었다<br>
 (도구는 '필요한 기능을 구현하는 방법'이며, <br>
  정책은 '결정을 내리는 방식'이다)<br>

 - 도구?<br>
  : 거의 모든 OS가 채택하는 것은 '시분할(time sharing)' 기법이다<br>
    이를 통해 원하는 만큼의 프로세스를 동시에 실행할 수 있다<br>
    '문맥 교환/전환 (Context switching)' 을 통해, CPU가 현재<br>
    프로세스에 대한 Context를 저장하고, 중지시킨 뒤 다른 프로세스의<br>
    Context를 복구하고 중단된 곳부터 재실행 시키는 방식으로<br>
    여러 프로세스를 동시에 실행하는 것처럼 보이게 한다<br>

 - 정책?<br>
  : 어떠한 결정을 내리는 일종의 '알고리즘'이다<br>
  '스케쥴링 정책'이라고도 한다<br>

## 프로세스의 상태(State)
 - 실행(Running) : 프로세스는 현재 프로세서(CPU)에 의해 실행 중<br>
  (즉, 명령어 실행 중)
 - 준비(Ready) : 실행할 준비는 되어 있으나, '대기' 중이다<br>
 (타 프로세스 실행 등으로 CPU가 현재 사용중이면 현재 프로세스는 대기한다)<br>
 - 대기(Blocked,Waiting State) : 현재 프로세스가 '어떠한 이벤트'를 기다리는 중<br>
 (ex : I/O 인터럽트 및 파일 Open 등의 시스템 콜로 인하여 해당 작업이 끝나기를 기다림)<br>
 실행과 준비 상태는 OS의 '스케쥴링 정책'에 따라<br>
 전환될 수 있다<br>

 운영체제도 '프로그램'이기에 '준비 상태'의 프로세스들을 관리하기 위하여<br>
 '프로세스 리스트' 자료 구조를 사용한다<br>

 이러한 프로세스는 '레지스터 문맥'이라는 자료구조를 사용하고<br>
 프로세스가 중단될 때, 해당 프로세스의 '레지스터'의 값을 저장한다<br>
 프로세스가 다시 '실행'상태가 될 때, 운영체제는<br>
 이러한 '레지스터'의 값을 '복원'하여 프로세스를 실행 시점으로 재시작한다<br>
 (이것이 문맥 교환이다!)<br>

## 쓰레드(Thread)
 '프로세스'의 실행 단위<br>
 프로세스의 자원을 공유하며, 독립적으로 실행된다<br>
 (쓰레드는 프로세스의 '실행 흐름'을 담당하고, 일반적으로 커널에서 관리됨)<br>

(하드웨어의 쓰레드 : CPU 내부에 존재하는 CPU의 실행 흐름<br>
하이퍼스레딩 기술은, 하나의 코어가 여러 개의 논리적 스레드를 처리할 수 있게 함<br>
그렇기에 하나의 코어에 추가적인 레지스터가 들어가게 된다(ex : ALU))<br>

'멀티쓰레드'의 경우, <br>
하나의 프로세스가 동시에 여러 작업을 수행할 수 있도록 함<br>

멀티 쓰레드 프로세스의 경우<br>
각 '쓰레드' 당 '스택' 영역을 가지게 된다<br>

또한 프로세스의 상태는 PCB(Process Control Block)으로 관리되듯,<br>
스레드의 상태는 TCB(Thread Control Block)으로 관리되며,<br>
이를 통해 '문맥전환'이 이루어진다<br>
(다만 쓰레드의 경우, 같은 프로세스 내에서 이루어지기에<br>
같은 가상 주소 공간을 이용하며, 사용하는 '페이지 테이블'을 그대로 사용하기에<br>
오버헤드가 적다)<br>
