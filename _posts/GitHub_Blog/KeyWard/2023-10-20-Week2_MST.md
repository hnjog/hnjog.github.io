---
title: "MST"
last_modified_at: "2023-10-20T13:10:00"
categories:
  - 크래프톤 정글
tags:
  - 크래프톤 정글
  - 키워드
  - 최소 신장 트리
---

## MST (최소 신장 트리)
  * 신장 트리??<br>
    : 어떤 그래프 안에 있는 모든 노드를 연결하는 트리<br>
    그래프 안에 있는 변만을 사용<br>
    신장 트리는 여럿 있을 수 있음<br>

  * 최소 신장 트리<br>
    : 신장 트리 중 '비용'이 최소인 트리<br>
    (비용 : 모든 변의 가중치를 합한 값)<br>
    (최소 '비용' 신장 트리 라고도 함)

  * 최소 신장 트리에서 '간선의 개수?' : N -1 개

  * 순환 : '반복되는 노드가 시작 노드 끝 노드 뿐인 경로'<br>
  
  * 컷 : 어떤 그래프를 서로소(disJoint)인 두 하위 집합<br>
  으로 나누는 행위<br>
  '그래프의 노드' 들을 두 그룹으로 분리시키는 것<br>
  컷 세트 (cut - set) : 두 그룹을 연결하는 간선들의 집합<br>
  -> 이 간선들을 제거하면 그래프가 둘로 분리됨<br>

  * 컷 프로퍼티(cut property)<br>
  컷 세트에 가중치가 다른 여러 간선이 있는 경우,<br>
    (가중 그래프임을 가정)<br>
  MST에 포함되는 간선은 가장 가중치가 작은 간선<br>

## MST 의 기본 원리
  1. 그래프에 있는 노드 중 한 변을 확인
  2. 이 변이 MST에 들어가야 하는지 검사<br>
    이 때, cut property를 사용<br>
    들어가야 하면 MST에 추가, 아니면 무시
  3. MST의 모든 변을 찾지 못했다면 1로 돌아감

  * Greedy 알고리즘

## MST 알고리즘의 예시
  - Kruskal's Algorithm<br>
   1. 그래프의 각 노드마다 그 노드만 포함하는 트리를 만듦
   2. 모든 간선의 가중치의 오름차순 정렬 => S 배열<br>
   (정확히는 각 간선이 '무엇'과 '무엇'을 가리키는지도 필요)
   3. S가 비거나 MST가 완성될 때까지 다음을 반복<br>
      1) S에서 가중치가 가장 적은 간선을 제거해서 고려
      2) 이 간선이 두 트리를 연결하는지 검사<br>
        => 그렇다면 MST에 추가<br>
           아니라면 버림<br>
        (두 트리를 연결하는지 검사하는 데 필요한 것이<br>
        '서로소집합' 자료구조)

      - 시간복잡도 : O(E Log E) (변 정렬)<br>
                + 서로소집합 시간 복잡도<br>
                (약 O(E Log V))

  - Prim's Algorithm<br>
   1. 아무 노드 하나 골라 트리를 만듦<br>
   2. 이 트리를 성장시킬 수 있는 간선을 하나 고름<br>
      아직 트리에 속하지 않은 노드와 연결하는 간선 중<br>
      비용이 가장 적은 간선<br>
      이미 트리에 속해있는 노드와 연결하는 변이면 무시<br>
  3. MST가 완성되거나 고려할 변이 없을때까지 2번 반복!<br>
    (다익스트라와 비슷한 느낌)

## 유니온 - 파인드 (서로소집합 자료구조)
  겹치지 않는 '집합'들을 저장하는 자료 구조<br>
  서로 다른 트리는 '겹치지 않는' 집합<br>
  이걸 서로소 집합에 저장하면 간단한 연산만으로<br>
  겹치는지 파악 가능<br>
  Union-Find, disjoint-set 등으로 불림

  * 연산 방법<br>
    - MakeSet(element) : 새로운 집합 생성<br>
      (새로운 요소 여야 한다)
    - Find(element) : element가 속한 집합을 찾음<br>
      ex) find(x) != find(y) : 둘은 다른 집합!<br>
      가장 간단한 구현은 '집합'에 속한 요소 중 하나를<br>
      결정론적으로 반환<br>
    - Union(element1,element2) : 두 집합을 합침<br>
      element1 이 속한 집합 + element2 가 속한 집합<br>

  * 크러스컬 알고리즘 적용방식<br>
    1. 그래프에 있는 각 노드 N에 대해 MakeSet(N)<br>
    2. 모든 변을 가중치의 오름차순으로 정렬(S 배열)<br>
    3. S가 비거나 MST가 완성될 때까지 다음의 과정 반복<br>
      1) S에서 가중치가 가장 적은 간선을 제거
      2) 이 간선이 연결하는 두 노드 u,v에 대해<br>
          Find(u) != Find(v) 라면<br>
          Union(u,v)<br>
          이 변을 MST에 추가하기<br>
