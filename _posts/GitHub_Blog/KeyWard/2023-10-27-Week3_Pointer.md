---
title: "포인터"
last_modified_at: "2023-10-27T20:30:00"
categories:
  - 크래프톤 정글
tags:
  - 크래프톤 정글
  - 키워드
  - 포인터
  - 연산자
---

## 포인터
  '메모리 주소 값'을 저장하는 변수<br>
  
  대표적인 예시로<br>

  'int' '*' a = (int *)malloc(n * sizeof(int));;<br>
  위 내용은 'int' 타입을 가리키는 '포인터 변수' a를 선언한 것이다<br>
  ~~(뒤의 malloc 과 캐스팅 은 지금은 무시하자)~~
  
  요점은 '주소값'을 표현하는 '타입'이라는 것<br>

  (<타입> * 으로 해당 타입의 주소값을 가리킨다 인식해도 된다)<br>

  * 왜 <타입> 이 필요하지??<br>
    => 그래야 '얼마만큼'의 크기를 '어떠한 타입'으로 가리킬 지<br>
    알 수 있으니까!!


## 주소 연산자 &
  Ampersand 라 불리는 주소 연산자 & 이다<br>
  ~~(펭귄이라 부를수도 있지만)~~

  - 비트 연산자 & 와 착각하지 말 것!<br>
    : 피연산자를 2개 쓰면 비트 연산자로 쓰여지므로 주의<br>
    (and 연산을 하면 두 피연산자의 '비트 패턴'을 비교하고 양쪽다<br>
    1이 있는 새로운 비트 패턴을 가진 값으로 반환한다)

  - 피연산자의 '주소값'을 보여준다<br>
    _(16진수로 보여준다)_

  위의 예시와 합쳐<br>
  int* a = &num ; <br>
  으로 사용이 가능하다!<br>
  (int 타입 포인터 변수 a에 num의 주소값을 대입)<br>

## 역참조 연산자 *
  '포인터가 가리키는 주소'의 값을 가져오는 연산자<br>
  
  위의 예시인<br>
  int* a = &num ; <br>
  로 보자면<br>
  a 포인터 변수에 저장된 int형의 num 값을 보고 싶다면<br>
  print("%d",*a) 로 볼 수 있다<br>
  
  * 참조와 역참조<br>
    - 참조<br>
     : 포인터가 하는 일<br>
     '변수'의 값을 직접 가져다 사용하는 것이 아니라<br>
     '어느 위치'에 존재한다고 가리킴<br>
    - 역참조<br>
     : 주소로 직접 가서 거기 저장되어 있는 값에 접근<br>

 '원본'의 값을 바꾸는 방식이기도 하다<br>
 int score = 100;<br>
 int* p = &score;<br>
 *p = 50;<br>
 => 이러면 score의 값이 50으로 바뀐다

## 값에 의한 전달 vs 참조에 의한 전달
  포인터를 함수 매개변수를 통해 전달하여<br>
  함수 내부에서 사용이 가능하다<br>

  void func(int* _a)<br>
  {<br>
    print("%d\n",*_a);<br>
    *_a = 20;<br>
  }<br>

  메모리 주소를 '복사'하여 전달하였으니 '값에 의한 전달'??<br>
  하지만 '원본'이 바뀌니 '참조에 의한 전달'??<br>

  => 실제 내부로는 '메모리 주소'를 전달하므로 '값에 의한 전달'이 맞지만<br>
  '원본'이 바뀐다는 점에서 '참조에 의한 전달' 이라는 것이 올바른 의도 전달 방식<br>


## 포인터를 함수 반환값으로 사용하면??
  포인터도 함수 값으로 반환이 가능!!<br>
  int* do_something(int a, int b);<br>

  다만 유의할 점이 존재한다<br>
  '함수의 지역변수'를 반환하지 말 것!<br>

  int* add(int a, int b){<br>
    int result = a + b;<br>
    return &result;<br>
  }<br>

  위 코드는 지역변수 'result'를 반환하고<br>
  이는 함수가 종료할 때,<br>
  해당 변수 스코프를 벗어나기에<br>
  결과적으로 반환되는 포인터는<br>
  '유효하지 않은 주소'를 가리키게 된다<br>

  그렇기에 함수에서 '주소'를 반환하는 경우는<br>
  - 전역변수
  - static 전역 변수
  - 함수 내 static 변수
  - 힙 메모리 생성 데이터를 가리킴<br>
    등의 경우가 보통

## 댕글링 포인터 (dangling pointer)
  위 같은 예시의 포인터처럼<br>
  '유효하지 못한 주소'를 가리키는 포인터를<br>
  '댕글링 포인터'라고 부른다<br>

  이러한 댕글링 포인터를 사용하면<br>
  결과를 예상할 수 없다<br>
  (정상적으로 값이 출력될지, 터질지...)<br>

## NULL 포인터
  '반환할 주소'가 없는 경우,<br>
  혹은 '포인터' 변수를 초기화하는 경우<br>
  '아무것도 가리키지 않는다'는 의미로 아래와 같이 사용한다<br>

  int* a = NULL; <br>

  (여기서 NULL은 상수 0 혹은 (void*)0 으로 표현된다)<br>

  NULL은 보통 3가지 방식으로 사용한다<br>
  1. 포인터 변수 초기화
  2. 포인터 주소가 '유효'한가 확인하기 (if a != NULL)
  3. 댕글링 포인터를 막기 위하여 (free()이후 유효하지 못한 주소를 가리키는 경우를 막음)
 

 