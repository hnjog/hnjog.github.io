---
title: "가상메모리"
last_modified_at: "2023-11-09T16:20:00"
categories:
  - 크래프톤 정글
  - CS
tags:
  - 크래프톤 정글
  - CS
---

## 가상 메모리
  '가상 메모리(virtual memory,VM)' 는<br>
  메모리 관리 기술 의 일부로,<br>
  메인 메모리 (RAM) 과 보조 기억 장치(HDD,SSD) 의 조합으로 이루어진다<br>
  '가상 메모리 주소 공간'의 개념을 이야기 하는 표현으로도 사용된다<br>

  - 가상 메모리 주소 공간<br>
    code, data, bss, stack, heap 등의 영역이 존재하며<br>
    프로세스 마다 주어지는 가상의 공간이다<br>
    이는 마치 연결되어 있는 것처럼 보인다<br>
    => 다만 실제로는 '메인 메모리'에 분리되어 위치할 수도 있고,<br>
    (페이징 기법)<br>
       '메인 메모리'가 부족한 경우는 '보조 기억 장치'에 저장될 수 있음<br>

    이러한 영역의 주소는 '가상 주소'라 표현한다<br>
    이와 반대되는 '물리 주소(실제 주소)'는<br>
    '메인 메모리'의 주소이다<br>

    => 물리 주소는 메인 메모리를 가리키는 주소이며<br>
       가상 주소는 '가상 메모리 주소 공간'에서 사용되는 주소이다<br>
       이러한 두 요소를 매핑하여 실제 데이터 위치에 접근한다<br>
    
    프로세스가 시작되면,<br>
    code,data 영역은 메인 메모리로 로드되며<br>
    bss 영역은 프로세스 시작 시, 동적 할당이 되고<br>
    스택은 프로시저 호출 시, 스택 프레임이 생성되고 동적 할당이 된다<br>
    힙은 동적 메모리 할당을 위해 동적으로 할당되고 해제된다<br>

    다만 메인 메모리가 부족한 경우,<br>
    보조 저장 장치에 데이터를 저장한다<br>

## 페이지
  페이지는 일정한 크기로 나뉘는 '데이터 블록'을 표현한다<br>

  - 페이지 관련 용어<br>
    가상 페이지 : 프로세스가 사용하는 가상 메모리 공간에서<br>
    페이지 번호로 식별되는 페이지<br><br>
    물리 페이지 : 실제 메인 메모리에 위치한 페이지<br>
    가상 페이지와 매핑된다<br><br>
    페이지 테이블 : 가상 주소와 물리 주소 간의<br>
    매핑 정보를 저장하는 데이터 구조<br>
    페이지 테이블은 프로세스의 가상 페이지와<br>
    실제 메인 메모리의 물리 페이지 간의
    매핑을 관리<br><br>
    페이지 오류 : CPU가 가상 페이지를 요청했으나<br>
    해당하는 페이지가 메인 메모리에 없는 경우<br>
    발생하는 예외 상황이다<br>
    페이지 오류는 페이지 테이블을 통해<br>
    디스크에서 필요한 데이터를 가져와<br>
    메모리에 로드하는 동안 처리<br>
    (페이지 테이블이 비어 있는 경우<br>
    즉, 가상 페이지가 매핑되어 있는 페이지가 비어 있는 경우<br> : 정확히는 해당 내용이 보조 기억 장치에 있는 경우이다)<br><br>
    스왑(swapping) : 페이지 오류가 발생하면<br>
    필요한 데이터를 디스크에서 메모리로 이동시키는 프로세스<br>
    해당 작업은 OS가 담당하고,<br>
    메인 메모리의 '희생자 페이지'로 선정된<br>
    (이 방식은 페이지 선택 알고리즘에 의존)<br>
    희생자 페이지를 disk에 보내고<br>
    해당 위치에 필요한 페이지를 로드한다<br><br>
    
    스왑 공간 : 디스크 상의 특정 영역을 가리키는 용어<br>
    '희생자 페이지'의 데이터를 저장하는 공간이다<br><br>

    스왑 인 : 디스크에서 메모리를 복사하는 작업<br>
    페이지 오류 시, 필요한 데이터를 디스크에서 메모리로 스왑<br><br>

    스왑 아웃 : 메모리에서 디스크로 데이터를 복사하는 작업<br><br>
    
    Page Table Entry(PTE):<br>
    페이지 테이블의 각 항목<br>
    매핑 정보를 저장한다<br>
    유효 비트 (메인 메모리 존재 여부)<br>
    물리 페이지 번호(유효하다면, 메인 메모리의 어디에 존재하는 지 표시)<br>
    변경 비트(dirty bit, 메인 메모리에서 수정되었는지 표시)<br>
    참조 비트(메인 메모리에서 참조되었는지 체크,<br> 오랫동안 참조되지 않은 경우 등 페이지 교체 알고리즘에서 사용)<br>
    보호 비트(접근 권한 제어)<br>
    등을 포함<br>

- 페이지의 상태<br>
    - Cached<br>
    현재 메인 메모리에 로드되어 있으며, CPU 또는 프로세스가 이 페이지에 접근할 때,<br>
    메인 메모리에서 데이터를 가져오지 않고 직접 액세스할 수 있는 페이지<br>
    
    - UnCached<br>
    메인 메모리에 할당된 페이지나,<br>
    이전에 CPU나 프로세스가 접근하지 않았거나 가장 최근에 접근이 끝난 페이지<br>

      요청시 cached 페이지 상태로 변경<br>

    - UnAllocated<br>
    현재 메인 메모리에 로드되지 않은 페이지<br>
    필요 시, 메인 메모리에 로드된다<br>

-  페이징<br>
  메인 메모리를 일정한 크기의 블록(페이지)으로 나누는 기법<br>

    이렇게 나눈 데이터는 '연속되지 않게' 저장될 수 있다<br>

    '일정한 크기'로 데이터를 할당하며<br>
    연속되지 않은 블록도 '가상 메모리 주소'를 통해 할당 가능하기에<br>
    외부 단편화 문제를 해결하는데 효과적이다<br>

    (페이지의 크기를 작게 하는 경우<br>
    내부 단편화를 완화할 수 있지만<br>
    페이지 테이블 관리에 오버헤드가 발생할 수 있기에 성능이 저하될 수 있음)


- 단편화<br>
  - 외부 단편화<br>
    : 메모리 내의 여유 공간이 작은 조각들로 나뉘어 있는 상태<br>
    총 여유 메모리 공간은 충분하나,<br>
    한번에 할당한 양은 부족하여<br>
    메모리 공간을 낭비하는 상황<br>
  - 내부 단편화<br>
    : 할당된 메모리 공간이 실제로<br>
    사용 중인 데이터 보다 큰 상태<br>
    사용되지 않는 할당 메모리 공간이 있어<br>
    낭비되고 있는 상황<br>

  - 단편화의 해결 방법<br>
    압축 : 메모리 공간을 재배치하여, 분산되어 있는 공간을 하나로 합치는 방식<br>
    (ex : 디스트 조각 모음)<br>
    통합(coalescing) : 단편화로 인해 분산된 메모리를<br>
    인접한 것들끼리 통합하여 큰 메모리 공간으로 합친다<br>
    (재배치 하지는 않는다)<br>
    페이징 : 위에서 설명<br>
    세그먼테이션(Segmentation)<br>
    : 가상 메모리 방식, 내부 단편화 해결, 외부 단편화 존재<br>
    페이징과는 다른 논리적 단위 사용,<br>
    다만 '세그먼트' 각 프로세스마다 다르기에<br>
    미리 분할할 수는 없으며, 빈 공간을 찾아 반환<br>
    (매핑을 위해 세그먼트 테이블 필요)<br>
    (프로세스가 필요한 메모리만큼 할당해주기에,<br>
    내부 단편화는 일어나지 않으나, 각 프로세스마다<br>
    공통된 단위가 없기에 외부 단편화는 일어날 수 있음)<br>
    (가상 메모리를 이용하는 방식은 페이징 기법과 비슷)<br>
    
    
