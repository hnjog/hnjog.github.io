---
title: "Chap1_컴퓨터시스템으로의 여행"
last_modified_at: "2023-10-19T17:00:00"
categories:
  - CSAPP
tags:
  - CSAPP
  - CS
---

## 1.5 캐시가 중요하다!
 시스템은 '정보'를 이동시키는 일에<br>
 _많~~은_ 시간을 사용한다<br>
 hello 프로그램은 하드 디스크에 저장되어 있었으며,<br>
 프로그램이 로딩될 때, '메인 메모리'에 <b>복사</b>된다<br><br>
 프로세서가 프로그램을 실행할 때,<br>
 '인스트럭션'들은 '메인 메모리' 에서<br>
 '프로세서'로 복사된다<br>
 또한 "Hello,World!"라는 데이터 스트링도<br>
 디스크 -> 메인 메모리 -> 프로세서<br>
 의 순서로 복사된다!<br><br>

 프로그래머의 관점에서 이는 '작업 속도'를<br> 떨어뜨리는 오버헤드이다.

  - 오버헤드 : 특정 목표를 실행하기 위해<br>
  사용되는 추가적인<br> 시간,메모리, 리소스, 비용 등을 얘기한다<br>
  성능에 직접적인 영향을 끼치기에<br>
  '성능저하'를 의미하기도 한다

 따라서 시스템 설계자의 주 목적은 <br>
 이러한 '복사과정'을 최대한 빠르게 동작하게<br>
 만드는 것!

 물리학의 법칙으로 더 '큰 저장장치'들은<br> '작은 저장장치'보다 느린 속도를 가지며,<br>
 더 많은 용량을 저장 가능하며,<br>
 더 저렴하다<br>

 그렇기에 '메인 메모리'를 빠르게 하는 것보다<br>
 '프로세서'를 더욱 빠르게 만드는 것이<br>
 더 쉬우며, 더 저렴하다<br>
 
 이러한 프로세서 - 메모리 격차에<br>
 대응하기 위하여 시스템 설계자는 보다<br>
 작고 빠른 <b>'캐시 메모리'</b>라는<br>
 저장장치를 고안하여,<br>
 프로세서가 '단기간에 필요로 할 가능성이<br> 높은 정보'를 임시저장할 목적으로 사용한다<br><br>

 가장 빠른 L1 캐시부터,<br>
 L2...L3... 로 숫자가 내려갈 때마다<br>
 속도는 낮아지고, 저장 용량은 늘어난다<br>
 이들은 SLAM(static Random Access Memory)<br>
 기술로 구현한다.<br><br>

 캐시는 '지역성'을 활용하여,<br>
 시스템이 마치 크고 많은 메모리를 활용하는 것과<br>
 동일한 효과를 주게 할 수 있다

  - 지역성<br>
  : 프로그램은 '모든' 코드나 데이터를 <br>'균등'하게       Access 하지 않는다<br>
  '어느 한 순간'에 '특정 영역'을 집중적으로 참조한다

  - 지역성의 종류<br>
  시간적 지역성(Temporal Locality)<br>
  : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조된다<br>
  => 메모리 상의 같은 주소에 여러 차례 읽기/쓰기 수행 시,<br>
    상대적으로 '작은 크기'의 캐시를 사용해도 효율적이다
     
    공간적 지역성(Spatial Locality)<br>
    : 공간적 지역성은 기억장치 내에 서로 인접하여<br>
    저장되어 있는 데이터들이 연속적으로 Access 될<br> 가능성이 높아진다는 특성이다.<br>
    => CPU 캐시나 디스크 캐시의 경우, 한 메모리 주소에<br>
    접근할 때, 그 주소뿐 아니라 해당 블록 전부 캐시에 가져온다<br><br>
    이 때, 메모리 주소를 '오름차순'/ '내림차순'으로<br>
    접급한다면 캐시에 이미 저장된 같은 블록의 데이터를 접근!<br>
    => 효율성 상승!!


  - 캐시 용어<br>
    <b>캐시 적중(Cache Hit)</b><br>
    : CPU가 액세스하려는 데이터가 이미 캐시에 적재되어 있음<br><br>
    <b>캐시 미스(Cache Miss)</b><br>
    : CPU가 액세스하려는 데이터가 캐시에 없어 메인 메모리로부터 인출해야 함<br><br>
    <b>캐시 적중률(Cache Hit Rate)</b><br>
    : CPU가 원하는 데이터가 캐시에 있을 확률<br>
    (캐시에 적중되는 횟수 / 전체 기억장치 액세스 수)<br><br>
    <b>미스율(Miss Rate)</b><br>
    : CPU가 원하는 데이터가 캐시에 없을 확률<br>(1 - 캐시 적중률)<br><br>


## 1.6 저장장치들은 계층구조를 이룬다
  작고 빠른 저장장치(ex : 캐시 메모리)를<br>
  프로세서와 좀 더 크고 느린 장치(ex : 메인 메모라)<br>
  사이에 끼워 넣는 '개념' 이 일반적인 아이디어로 판명되었다<br>

  이러한 주요 아이디어의 '개념'은<br>
  한 level의 저장장치가 다음 하위레벨 저장장치의<br>
  '캐시' 역할을 한다는 것이다<br><br>

  * 로컬 디스크는 '원격 네트워크'에서 파일을 가져와<br>
  미리 보관함으로서, 네트워크의 '캐시' 역할이 가능하다

# 1.7 운영체제는 하드웨어를 관리한다
  한 가지 주목할 점은<br>
  쉘 프로그램이 'Hello' 프로그램을 로드하고<br>
  실행했을 때, 프로그램이 '키보드','디스플레이','디스크',<br>'메인 메모리'를 직접 엑세스 하지 않는다는 점이다<br><br>

  오히려 운영체제(Operation System, OS)의 서비스를<br>
  제공받아 활용한다<br>

  이에 따라서, 운영체제는 '하드웨어'와 '소프트웨어' 사이에<br>
  존재한 계층으로 생각할 수 있다<br>
  => 고로, 응용프로그램(Application)이 하드웨어를<br>
  제어하려면 언제나 운영체제를 거쳐야 한다

  - 운영체제의 2가지 목적
  1. 제멋대로 동작하는 응용프로그램이<br>
     하드웨어를 잘못 사용하는 걸 막기 위함
  2. 응용프로그램이 단순하고 균일한 매커니즘으로<br>
     복잡하고 서로 다른 저수준 하드웨어를 조작할 수 있도록

  운영체제는 이러한 목표를 '추상화'를 통해<br>
  달성하고 있다<br>

  _<b> 프로세스 , 가상메모리, 파일</b>_<br>

  파일 : '입출력장치' 의 추상화<br>
  가상메모리  : '메인 메모리' 와 '입출력장치'의 추상화<br>
  프로세스 : '프로세서','메인 메모리', '입출력장치'의 추상화

## 1.7.1 프로세스
  프로그램이 실행될 때, 마치 프로그램이<br>
  '프로세서','메인 메모리', '입출력장치'를 독차지하는<br>
  것처럼 느껴진다<br>
  => '프로세스' 개념의 결과물!<br>

  프로세스는 실행 중인 '프로그램'에 대한<br>
  '운영체제'의 '추상화'이다<br>

  다수의 '프로세스'들은 동일한 시스템에서<br>
  동시에 실행될 수 있고,<br>
  각 프로세스는 하드웨어를 배타적으로 사용하는 것처럼
  느낀다.<br><br>

  '프로세서'가 '프로세스'들을 바꿔주는 방식으로<br>
  하나의 CPU가 다수의 프로세스를 동시에 실행하는것처럼 보이게 해준다<br><br>

  운영체제는 '문맥 전환'_(Context Switching)_ <br>
  이라는 방법으로 교차수행을 실행한다<br><br>

  운영체제는 프로세스가 실행하는데 필요한 모든<br>
  상태정보의 변화를 추적한다<br>
  '컨택스트'라고 부르는 이 상태정보는<br>
  PC(program Counter), 레지스터 파일, 메인 메모리의<br>
  현재 값을 포함한다<br><br>
  이 값을 사용하여, 운영체제는 다른 프로세스로 제어를<br>
  옮길 때, 현재 프로세스의 컨택스트를 '저장'하고<br>
  새 프로세스의 컨택스트를 '복원'시키는 문맥전환을<br>
  실행한 뒤, 제어권을 새 프로세스에 넘긴다<br>

## 1.7.2 쓰레드(Thread)
  프로세스는 최근의 시스템에서는 쓰레드(thread)라는<br>
  다수의 실행 유닛으로 구성되어 있다<br>

  각각의 쓰레드는 해당 프로세스의 컨택스트에서 실행되며<br>
  동일한 '코드'와 '전역 데이터'를 공유한다<br>

  최근 '프로그래밍 모델'로서의 중요성이 점점 증가하는데,<br>
    - 다수의 프로세스들에서보다 데이터 공유가 더 쉽고<br>
    - 쓰레드가 프로세스보다 더 효율적 이라는 점이다<br>

  * 프로세스와 쓰레드의 차이점?<br>
  1. 기본적인 정의<br>
    - 프로세스 : 독립적으로 실행되는 프로그램의 인스턴스<br>
    자체적인 주소 공간, 메모리, 데이터 스택 및<br>
    다른 시스템 자원을 갖는다<br>
    - 스레드 : 프로세스 내부의 실행 흐름 단위로<br>
    프로세스의 자원과 주소 공간을 공유하면서 실행<br><br>
  2. 자원 공유<br>
    - 프로세스 : 각 프로세스는 독립적인 메모리 공간과<br>시스템 자원을 가지므로,<br>
    프로세스간 자원 공유는<br>
    IPC(Inter-Process Communication)<br>
    매커니즘을 통해 이루어진다<br>
    - 쓰레드 : 같은 프로세스 내의<br>
    쓰레드들은 코드,데이터 및<br>
    시스템 자원을 공유합니다<br>


## 1.7.3 가상 메모리
  가상 메모리는 '각 프로세스' 들이<br>
  '메인 메모리 전체를 독점하여 사용하는 듯'한<br>
  착각을 주는 추상화이다<br>

  프로세는 '가장주소 공간'이라는 균일적 메모리의<br>
  모습을 가지게 된다<br>

  - 프로그램 코드와 데이터 영역
  - 힙 영역 (Runtime Heap) : malloc / free
  - 공유 라이브러리
  - 스택 : 함수 호출
  - 커널 가상메모리 : 커널을 위한 공간

  - 운영체제 '메모리 관리 시스템'의 핵심 부분

  이러한 방식이 동작하기 위해서,<br>
  프로세서가 만들어내는 모든 주소를<br>
  '하드웨어'로 번역하는 등<br>
  하드웨어와 운영체제 소프트웨어 간의<br>
  복잡한 상호작용이 필요하다

## 1.7.4 파일
  파일은 '그저 연속된 바이트들'이다<br>
  디스크, 키보드, 디스플레이,네트워크 까지<br>
  모든 '입출력장치'는 파일로 모델링한다<br>

  응용프로그램에 시스템에 들어 있는 다양한<br>
  입출력장치들의 '통일된 관점'을 제공한다<br>
  (프로그래머는 '어떠한' 하드웨어에서<br>
  사용하는 '특정한' 기술을 알지 않아도 된다!)

## 1.8 시스템은 '네트워크'를 사용하여 다른 시스템과 통신한다
  개별 시스템의 관점으로 볼 때,<br>
  네트워크는 또 다른 '입출력장치'라고<br>
  볼 수 있다<br>

  시스템이 '메인 메모리'로부터 네트워크 어댑터로<br>
  일련의 바이트를 복사할 때,<br>
  데이터는 로컬디스크 드라이브 대신에<br>
  네트워크를 통해 다른 컴퓨터로 이동한다<br>
  마찬가지로 시스템은 다른 컴퓨터에서 전송된 데이터를<br>
  메인 메모리에 복사할 수 있다<br>

  글로벌 네트워크(인터넷)의 출현으로<br>
  하나의 컴퓨터에서 다른 컴퓨터로 정보를<br>
  복사하는 것이 가장 중요한 컴퓨터의 응용이 되었다<br>
  (ex : 이메일, 메신저, 웹 페이지, FTP, telenet 등)<br>

  서버 <-> 클라이언트의 '데이터 교환'은<br>
  모든 네트워크 응용의 전형적인 사례이다<br>

## 1.9 중요한 주제들
  '시스템'은 단순한 하드웨어 이상이다!<br>
  '응용 프로그램의 실행' 이라는 목적을 달성하기 위해<br>
  하드웨어와 시스템 소프트웨어가 서로 연결된 것을 의미!<br>

## 1.9.1 Amdahl의 법칙
  우리가 어떤 시스템의 '한 부분'을 개선할 때,<br>
  전체 시스템 성능에 대한 효과는,<br>
  1. 그 부분이 얼마나 중요한가
  2. 이 부분이 얼마나 빨라졌나<br><br>

  에 관계되었다는 것이다<br>

  개선된 속도 S는 T(old) / T(new)를 통해 구할 수 있다<br>
  S = 1 / (1 - a) + a/k<br>

  a : 개선 부분의 실행 시간 소모율<br>
  k : 개선된 성능비율<br>

  ex) 전체 시간의 60%(a = 0.6)인<br>
      시스템 요소를 3배(k=3) 향상 시켰다면<br>
      실질적 성능향상은 1 / [0.4 + 0.6 / 3] = 1.67<br>
  
  - 전체 시스템 속도를 향상 시키려면<br>
    시스템의 매우 큰 부분의 성능을 개선해야한다
  
  만약 성능을 무한으로 향상시켜 해당하는 실행 시간<br>
  소모율이 0이 된 경우는<br>
  S = 1 / (1 - a) 가 된다<br>
  (k가 무한이므로 a/k 는 0에 가까움)<br>
  
  - 성능 향상은 '전체적'으로 '많은' 부분을<br>
    최적화시켜야 얻을 수 있다

## 1.9.2 동시성과 병렬성
  컴퓨터는 두 개의 요구가 지속적으로 성능개선을 주도하였다<br>
  더 많은 일, 더 빠른 실행<br>

  '동시성'은 다수의 동시에 벌어지는 일을 갖는<br>
  시스템에 대한 일반적인 개념을 말할 때 사용한다<br><br>
  '병렬성'은 동시성을 사용하여, 시스템을 보다<br>
  빠르게 동작하도록 하는것을 말할 때 사용한다<br><br>

  병렬성은 다양한 수준의 추상화에서 활용 가능하다<br>
  높은 계층에서 낮은 계층으로 이동하면서<br>
  '세 개'의 수준을 강조하고자 한다<br>

  - 쓰레드 수준 동시성<br>
    한 개의 컴퓨터는 실행하는 '프로세스'를 빠르게<br>
    전환하는 방법을 사용한다<br>
    하나의 프로세서로 이루어진 이 시스템 구성을<br>
    '단일 프로세서 시스템'이라 하며<br>
    다수의 프로세서로 이루어지며, 하나의 OS의<br>
    제어 하에 동작하는 것은 '멀티 프로세서 시스템'이라<br>
    한다<br>
    멀티 프로세서 시스템은 '멀티코어 프로세서'와<br>
    '하이퍼쓰레딩'기법의 출현으로 지금은 일반적인<br>
    환경이 되었다<br>

    멀티코어 프로세서는 '여러 개의 CPU'를 하나의<br>
    집적화된 칩에 내장하고 있다<br>
    이들은 각각 L1,L2 캐시를 가지고<br>
    코어는 메인 메모리 뿐 아니라<br>
    상위 수준 캐시를 공유한다<br>

    '멀티쓰레딩' 이라고도 하는 하이퍼쓰레딩은<br>
    하나의 CPU가 여러 개의 제어 흐름을 실행할<br>
    수 있게 해주는 기술이다<br>
    이는 PC나 레지스터 파일 같은 여러 개의<br>
    동일한 CPU 하드웨어를 가지고 있는 반면,<br>
    부동소수 연산기와 같은 다른 부분들은<br>
    하나만 가지고 구조와 관련이 있다<br>

    기존의 프로세서가 '쓰레드 간 전환'을 하는데<br>
    약 2만 클럭 사이클이 필요한 반면에<br>
    하이퍼쓰레드 프로세서에서는 매 사이클마다<br>
    실행할 쓰레드를 결정한다<br><br>

    이러한 멀티프로세싱의 이용으로 시스템 성능을<br>
    개선할 때 2가지 방법으로 이용이 가능하다 .<br>
    1. 다수의 태스크를 실행할 때, 동시성을<br>
       시뮬레이션할 필요를 줄여준다
    2. 멀티 프로세싱으로 한 개의 응용프로그램을<br>
    빠르게 실행할 수 있지만, 프로그램이 병렬로<br>
    효율적으로 실행할 수 있는 멀티쓰레드의<br>
    형태로 표현되었을 떄에만 가능하다<br>

  - 인스트럭션 수준 병렬성<br>
    최근의 프로세서들은 훨씬 낮은 수준에서의 추상화로<br>
    여러 개의 인스트럭션을 한 번에 실행 할 수 있다<br>
    이를 인스트럭션 수준 병렬성 이라 한다<br><br>

    프로세서는 여러 기법을 이용하여 한번에 100개의<br>
    인스트럭션까지 처리할 수 있다<br>

    '파이프라이닝'기법을 통해<br>
    하나의 인스트럭션을 실행하기 위해 요구되는 일을<br>
    '여러 단계'로 나누고<br>
    프로세서 하드웨어가 일련의 단계로 구성되어 이들<br>
    단계를 하나씩 각각 수행한다<br>
    이들 단계는 '병렬'로 동작할 수 이으며<br>
    서로 다른 '인스트럭션'의 다른 부분을 이용하여 동작<br><br>

    사이클당 한 개 이상의 인스트럭션을 실행할 수 있는<br>
    프로세서를 '슈퍼스케일러'라고 한다<br>

  - 싱글 인스트럭션, 다중 데이터 병렬성(SIMD)<br>
    많은 최신 프로세서는 최하위 수준에서 <br>
    싱글 인스트럭션, 다중 데이터, 즉 SIMD 병렬성이라는<br>
    모드로 한 개의 인스트럭션이 병렬로 다수의 연산을<br>
    수행할 수 있는 특수 하드웨어를 가지고 있다<br>
    이러한 SIMD 인스트럭션들은 대개<br>
    영상, 소리, 동영상 데이터 처리를 위한 응용 프로그램의<br>
    속도를 개선하기 위해 제공된다<br>
    일부 컴파일러 들은 자동으로 C 프로그램에서<br>
    SIMD 병렬성을 추출하는 시도를 하고 있지만<br>
    보다 안정적인 방법은 GCC 같은 컴파일러에서 지원하는<br>
    특수 벡터 데이터 형을 사용하여<br>
    프로그램을 작성하는 것이다<br>

## 1.9.3 컴퓨터 시스템에서 '추상화'의 중요성
  '추상화'의 사용은 전산한에서 가장 중요한 개념이다<br>
  좋은 프로그래밍 연습의 한가지 측면은<br>
  '함수'들을 간단한 응용프로그램 인터페이스 API로 정형화하는<br>
  것으로, 프로그래머가 내부의 동작을 고려하지 않으면서<br>
  코드를 사용할 수 있도록 해준다<br>
  (ex : player.draw() - 어떻게 그려주는지는 모르지만 호출!!)<br>

  프로세서 측면에서, '인스트럭션 집합 구조'는 실제<br>
  프로세서 하드웨어의 추상화를 제공한다<br>
  이러한 추상화로, 기계어 코드 프로그램은 마치 한 번에<br>
  하나의 인스트럭션을 실행하는 프로세서에서 실행되는 것처럼<br>
  동작한다.<br>

  실제 하드웨어는 훨씬 더 정교하여 여러 개의 인스트럭션을<br>
  병렬로, 그러나 항상 간단한 순차적인 모델에 의거한 방식으로<br>
  실행한다<br>

  동일한 실행모델을 유지하기에, 다른 프로세서에 구현될 때도<br>
  다양한 범위의 비용과 성능을 나타내지만,<br>
  동일한 기계어 코드를 실행할 수 있게 된다<br>

  현재 3가지 추상화를 소개하였다<br>
  파일 : 입출력장치 의 추상화<br>
  가상메모리 : 프로그램 메모리의 추상화<br>
  프로세스 : 실행중인 프로그램의 추상화<br>

  추가적으로 한가지를 더 소개하자면<br>
  '가상머신'을 들 수 있다<br>
  이는 운영체제, 프로세서, 프로그램을 모두 포함하는<br>
  '컴퓨터 전체'의 추상화를 제공한다<br>

# 1.10 요약
  '시스템'은 '응용프로그램'을 실행하기 위해<br>
  함께 동작하는 하드웨어와 시스템 소프트웨어로 구성된다<br>
  
  '정보'는 메인 메모리에 저장된 바이너리 인스트럭션을 읽고<br>
  해석된다.<br>

  컴퓨터가 대부분의 시간을 메모리, 입출력장치, CPU레지스터<br>
  간에 데이터를 복사하는 데 쓰고 있으므로<br>
  시스템의 저장장치들은 계층구조를 형성하여<br>
  CPU 레지스터가 최상위에,<br>
  하드웨어 캐시 메모리,<br>
  DRAM 메인 메모리,<br>
  디스크 저장장치 등이 순차적으로 위치한다<br>
  (상층에 있을수록 비트당 단가가 더 비싸고 빠르다)<br>

  계층구조 상부의 저장장치들은 하부의 장치들을 위한 캐시<br> 역할을 수행한다<br>

  운영체제 커널은 응용프로그램과 하드웨어 사이의<br>
  중간자 역할을 수행한다<br>
  이들은 3가지의 근본적인 추상화를 제공한다<br>
  1. 파일 : '입출력장치' 의 추상화<br>
  2. 가상메모리  : '메인 메모리' 와 '입출력장치'의 추상화<br>
  3. 프로세스 : '프로세서','메인 메모리', '입출력장치'의 추상화

  끝으로 네트워크는 컴퓨터 시스템이 서로 통신할 수 있는<br>
  방법을 제공한다<br>
  특정 시스템의 관점에서 보면 네트워크는 단지 또 하나의<br>
  '입출력장치'이다


  tmi_ 1장 요약에 시간이 다소 많이 걸렸기에
       이후는 가능한 요점만 파악하여 따로 포스팅하는걸로..

